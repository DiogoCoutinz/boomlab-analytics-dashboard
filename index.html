<!DOCTYPE html>
<html lang="pt-PT">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard de Analytics ‚Äî BoomLab</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

    <!-- Day.js + plugins -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>

    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
      /* Custom dark theme */
      body {
        background: #0f0f0f;
        color: #e5e5e5;
      }

      .card {
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        transition: all 0.2s ease;
      }

      .card:hover {
        border-color: #3a3a3a;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .tab {
        cursor: pointer;
        padding: 0.75rem 1.5rem;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
        color: #9ca3af;
      }

      .tab:hover {
        color: #e5e5e5;
      }

      .tab.active {
        color: #3b82f6;
        border-bottom-color: #3b82f6;
      }

      .skeleton {
        background: linear-gradient(90deg, #1a1a1a 25%, #2a2a2a 50%, #1a1a1a 75%);
        background-size: 200% 100%;
        animation: loading 1.5s ease-in-out infinite;
      }

      @keyframes loading {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th {
        position: sticky;
        top: 0;
        background: #1a1a1a;
        padding: 0.75rem;
        text-align: left;
        font-weight: 600;
        border-bottom: 2px solid #3a3a3a;
        cursor: pointer;
        user-select: none;
      }

      th:hover {
        background: #2a2a2a;
      }

      td {
        padding: 0.75rem;
        border-bottom: 1px solid #2a2a2a;
      }

      tr:hover {
        background: #1f1f1f;
      }

      select,
      input[type="date"] {
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        color: #e5e5e5;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
      }

      select:focus,
      input[type="date"]:focus {
        outline: none;
        border-color: #3b82f6;
      }

      .delta-positive {
        color: #10b981;
      }

      .delta-negative {
        color: #ef4444;
      }

      /* Chart container */
      .chart-container {
        position: relative;
        height: 300px;
      }

      .btn {
        background: #3b82f6;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn:hover {
        background: #2563eb;
      }

      .btn:disabled {
        background: #374151;
        cursor: not-allowed;
      }

      /* Tooltip icon */
      .tooltip-icon {
        display: inline-block;
        font-size: 0.75rem;
        opacity: 0.5;
        cursor: help;
        transition: opacity 0.2s ease;
      }

      .tooltip-icon:hover {
        opacity: 1;
      }

      /* Cursor help for tooltips */
      .cursor-help {
        cursor: help;
        text-decoration: underline;
        text-decoration-style: dotted;
        text-decoration-color: #3a3a3a;
        text-underline-offset: 2px;
      }

      .cursor-help:hover {
        text-decoration-color: #9ca3af;
      }

      /* Switch Toggle (iOS style) */
      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #374151;
        transition: 0.3s;
        border-radius: 24px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: #3b82f6;
      }

      input:checked + .slider:before {
        transform: translateX(24px);
      }

      /* Domain row */
      .domain-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background: #0f0f0f;
        border: 1px solid #2a2a2a;
        border-radius: 0.5rem;
        transition: all 0.2s ease;
      }

      .domain-row:hover {
        border-color: #3a3a3a;
        background: #1f1f1f;
      }

      .domain-row.disabled {
        opacity: 0.5;
      }

      /* Settings tabs */
      .settings-tab {
        cursor: pointer;
        padding: 0.75rem 1.5rem;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
        color: #9ca3af;
      }

      .settings-tab:hover {
        color: #e5e5e5;
      }

      .settings-tab.active {
        color: #3b82f6 !important;
        border-bottom-color: #3b82f6 !important;
      }

      /* Page row for obrigado settings */
      .page-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 0.75rem;
        background: #0f0f0f;
        border: 1px solid #2a2a2a;
        border-radius: 0.375rem;
        transition: all 0.2s ease;
      }

      .page-row:hover {
        border-color: #3a3a3a;
        background: #1a1a1a;
      }

      .page-row.is-obrigado {
        border-color: #10b981;
        background: rgba(16, 185, 129, 0.05);
      }

      /* Checkbox style */
      .checkbox-obrigado {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #10b981;
      }
    </style>
  </head>

  <body class="font-sans">
    <!-- Header -->
    <header class="border-b border-gray-800 bg-black/50 backdrop-blur-sm sticky top-0 z-50">
      <div class="container mx-auto px-6 py-4 flex justify-between items-center">
        <h1 class="text-2xl font-bold">üìà Dashboard de Analytics ‚Äî BoomLab</h1>
        <button id="btn-settings" class="btn flex items-center gap-2">
          ‚öôÔ∏è Defini√ß√µes
        </button>
      </div>
    </header>


    <!-- Filters -->
    <section class="border-b border-gray-800 bg-black/30">
      <div class="container mx-auto px-6 py-4">
        <div class="flex flex-wrap gap-4 items-end">
          <!-- Period -->
          <div class="flex-1 min-w-[200px]">
            <label class="block text-sm text-gray-400 mb-2">Per√≠odo</label>
            <select id="filter-period" class="w-full">
              <option value="today">Hoje</option>
              <option value="yesterday">Ontem</option>
              <option value="7d" selected>√öltimos 7 dias</option>
              <option value="30d">√öltimos 30 dias</option>
              <option value="90d">√öltimos 90 dias</option>
              <option value="ytd">Ano (YTD)</option>
              <option value="custom">Personalizado</option>
            </select>
          </div>

          <!-- Custom date range (hidden by default) -->
          <div id="custom-range" class="hidden flex-1 min-w-[200px] flex gap-2">
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-2">De</label>
              <input type="date" id="filter-date-from" class="w-full" />
            </div>
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-2">At√©</label>
              <input type="date" id="filter-date-to" class="w-full" />
            </div>
          </div>

          <!-- Domain (Hostname) -->
          <div class="flex-1 min-w-[200px]">
            <label class="block text-sm text-gray-400 mb-2">Dom√≠nio</label>
            <select id="filter-hostname" class="w-full">
              <option value="">Todos os dom√≠nios</option>
            </select>
          </div>
        </div>
      </div>
    </section>

    <!-- KPI Cards -->
    <section class="container mx-auto px-6 py-8">
      <div id="kpi-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-4">
        <!-- Skeletons (will be replaced) -->
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
      </div>
    </section>

    <!-- Tabs -->
    <section class="container mx-auto px-6">
      <div class="flex border-b border-gray-800">
        <div class="tab active" data-tab="overview">Vis√£o Geral</div>
        <div class="tab" data-tab="pages">P√°ginas</div>
        <div class="tab" data-tab="acquisition">Aquisi√ß√£o</div>
        <div class="tab" data-tab="conversion">Convers√£o</div>
      </div>
    </section>

    <!-- Tab Content -->
    <section class="container mx-auto px-6 py-8">
      <!-- Overview Tab -->
      <div id="tab-overview" class="tab-content">
        <div class="grid grid-cols-1 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Evolu√ß√£o Temporal</h3>
            <div class="chart-container" style="height: 300px;">
              <canvas id="chart-overview-timeline"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Pages Tab -->
      <div id="tab-pages" class="tab-content hidden">
        <!-- Domain breakdown (only when "Todos os dom√≠nios") -->
        <div id="pages-domain-breakdown" class="hidden mb-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">üìä Distribui√ß√£o por Dom√≠nio</h3>
            <div class="chart-container" style="height: 350px;">
              <canvas id="chart-domains-breakdown"></canvas>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Top P√°ginas</h3>
            <div class="overflow-x-auto">
              <table id="table-pages">
                <thead>
                  <tr>
                    <th data-sort="page_path">P√°gina</th>
                    <th data-sort="sessions">Sessions</th>
                    <th data-sort="unique_users">Users</th>
                    <th data-sort="avg_session_duration">Dura√ß√£o M√©dia</th>
                    <th data-sort="engagement_rate">Eng. Rate</th>
                    <th data-sort="bounce_rate">Bounce Rate</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">P√°ginas por Sessions</h3>
            <div class="chart-container">
              <canvas id="chart-pages-bar"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Acquisition Tab -->
      <div id="tab-acquisition" class="tab-content hidden">
        <div id="acquisition-content" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Sessions por Canal</h3>
            <div class="chart-container">
              <canvas id="chart-acquisition-donut"></canvas>
            </div>
          </div>
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Fontes de Tr√°fego</h3>
            <div class="overflow-x-auto">
              <table id="table-acquisition">
                <thead>
                  <tr>
                    <th data-sort="channel">Canal</th>
                    <th data-sort="source_medium">Fonte / Meio</th>
                    <th data-sort="sessions">Sessions</th>
                    <th data-sort="unique_users">Users</th>
                    <th data-sort="engagement_rate">Eng. Rate</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Empty state -->
        <div id="acquisition-empty" class="hidden card rounded-lg p-12 text-center">
          <svg class="mx-auto h-16 w-16 text-gray-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
          <p class="text-gray-400 text-lg">Sem dados de aquisi√ß√£o ainda</p>
          <p class="text-gray-500 text-sm mt-2">Os dados de canais e fontes aparecer√£o aqui quando dispon√≠veis</p>
        </div>
      </div>

      <!-- Conversion Tab -->
      <div id="tab-conversion" class="tab-content hidden">
        <div id="conversion-content" class="grid grid-cols-1 gap-6">
          <!-- KPIs de Convers√£o -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="card rounded-lg p-6">
              <h4 class="text-sm text-gray-400 mb-2">Total Convers√µes</h4>
              <div class="text-3xl font-bold" id="conversion-total-sessions">‚Äî</div>
              <div class="text-xs text-gray-500 mt-1">Sessions em p√°ginas de obrigado</div>
            </div>
            <div class="card rounded-lg p-6">
              <h4 class="text-sm text-gray-400 mb-2">Utilizadores Convertidos</h4>
              <div class="text-3xl font-bold" id="conversion-total-users">‚Äî</div>
              <div class="text-xs text-gray-500 mt-1">Utilizadores √∫nicos</div>
            </div>
            <div class="card rounded-lg p-6">
              <h4 class="text-sm text-gray-400 mb-2">Taxa de Engagement</h4>
              <div class="text-3xl font-bold" id="conversion-engagement-rate">‚Äî</div>
              <div class="text-xs text-gray-500 mt-1">Engagement m√©dio</div>
            </div>
          </div>

          <!-- Gr√°fico de Evolu√ß√£o -->
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">üìà Evolu√ß√£o de Convers√µes</h3>
            <div class="chart-container" style="height: 300px;">
              <canvas id="chart-conversion-timeline"></canvas>
            </div>
          </div>

          <!-- Tabelas -->
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Top P√°ginas de Convers√£o -->
            <div class="card rounded-lg p-6">
              <h3 class="text-lg font-semibold mb-4">üéØ Top P√°ginas de Convers√£o</h3>
              <div class="overflow-x-auto">
                <table id="table-conversion-pages">
                  <thead>
                    <tr>
                      <th data-sort="page">P√°gina</th>
                      <th data-sort="sessions">Sessions</th>
                      <th data-sort="users">Users</th>
                      <th data-sort="engagement">Engagement</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>

            <!-- Breakdown por Dom√≠nio -->
            <div class="card rounded-lg p-6">
              <h3 class="text-lg font-semibold mb-4">üåê Convers√µes por Dom√≠nio</h3>
              <div class="chart-container">
                <canvas id="chart-conversion-domains"></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Empty state -->
        <div id="conversion-empty" class="hidden card rounded-lg p-12 text-center">
          <svg class="mx-auto h-16 w-16 text-gray-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <p class="text-gray-400 text-lg">Nenhuma p√°gina de obrigado configurada</p>
          <p class="text-gray-500 text-sm mt-2">Vai √†s <button onclick="document.getElementById('btn-settings').click()" class="text-blue-500 hover:underline">Defini√ß√µes</button> e marca as p√°ginas de convers√£o</p>
        </div>
      </div>

    </section>

    <!-- Footer -->
    <footer class="border-t border-gray-800 bg-black/30 mt-12">
      <div class="container mx-auto px-6 py-4 flex justify-between items-center">
        <div class="text-sm text-gray-400">
          √öltima atualiza√ß√£o: <span id="last-update" class="font-mono">--:--</span>
        </div>
        <button id="btn-refresh" class="btn">
          üîÑ Atualizar
        </button>
      </div>
    </footer>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 z-[100] flex items-center justify-center">
      <!-- Backdrop -->
      <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" id="settings-backdrop"></div>
      
      <!-- Modal Content -->
      <div class="relative bg-[#1a1a1a] border border-gray-800 rounded-lg w-full max-w-3xl mx-4 max-h-[85vh] flex flex-col">
        <!-- Header -->
        <div class="border-b border-gray-800 px-6 py-4 flex justify-between items-center">
          <div>
            <h2 class="text-xl font-bold">‚öôÔ∏è Defini√ß√µes</h2>
            <p class="text-sm text-gray-400 mt-1">Configura√ß√µes do dashboard</p>
          </div>
          <button id="btn-close-settings" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
        </div>

        <!-- Tabs -->
        <div class="flex border-b border-gray-800 px-6">
          <div class="settings-tab active" data-settings-tab="domains" style="cursor: pointer; padding: 0.75rem 1.5rem; border-bottom: 2px solid transparent; transition: all 0.2s ease; color: #3b82f6; border-bottom-color: #3b82f6;">
            üåê Dom√≠nios
          </div>
          <div class="settings-tab" data-settings-tab="pages" style="cursor: pointer; padding: 0.75rem 1.5rem; border-bottom: 2px solid transparent; transition: all 0.2s ease; color: #9ca3af;">
            üéØ P√°ginas de Obrigado
          </div>
        </div>

        <!-- Tab Content -->
        <div class="flex-1 overflow-y-auto px-6 py-4">
          <!-- Domain List Tab -->
          <div id="settings-tab-domains" class="settings-tab-content">
            <div id="domains-list" class="space-y-3">
              <!-- Will be populated dynamically -->
              <div class="text-center text-gray-500 py-8">A carregar dom√≠nios...</div>
            </div>
          </div>

          <!-- Pages List Tab -->
          <div id="settings-tab-pages" class="settings-tab-content hidden">
            <div class="mb-4 p-3 bg-blue-900/20 border border-blue-800/30 rounded-lg">
              <p class="text-sm text-blue-300">üí° Marca as p√°ginas que s√£o de "obrigado" (convers√£o). Estas aparecer√£o no tab Convers√£o.</p>
            </div>
            <div id="pages-list" class="space-y-2">
              <!-- Will be populated dynamically -->
              <div class="text-center text-gray-500 py-8">A carregar p√°ginas...</div>
            </div>
          </div>
        </div>

        <!-- Footer -->
        <div class="border-t border-gray-800 px-6 py-4 flex justify-between items-center">
          <div class="text-sm text-gray-400">
            <span id="domains-count-active">0</span> ativos / <span id="domains-count-total">0</span> totais
          </div>
          <div class="flex gap-3">
            <button id="btn-cancel-settings" class="px-4 py-2 rounded-lg border border-gray-700 hover:bg-gray-800 transition">
              Cancelar
            </button>
            <button id="btn-save-settings" class="btn">
              Guardar
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ========================================
      // CONFIG
      // ========================================

      const CONFIG = {
        supabase: {
          url: 'https://uvvxvqrymdywxoqgnnvd.supabase.co',
          anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV2dnh2cXJ5bWR5d3hvcWdubnZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwODM3NDAsImV4cCI6MjA3NDY1OTc0MH0.3vNlo61Yl4c3XG7-8yDCKVBO4-f0iNMJeHXSSgzAI5w',
        },
        locale: 'pt-PT',
        timezone: 'Europe/Lisbon',
        colors: {
          primary: '#3b82f6',
          success: '#10b981',
          danger: '#ef4444',
          warning: '#f59e0b',
        },
      };

      // Metric descriptions for tooltips
      const METRIC_DESCRIPTIONS = {
        totalUsers: 'Utilizadores √∫nicos ativos (1-day active users). Sem duplica√ß√µes entre p√°ginas/dispositivos.',
        newUsers: 'Novos utilizadores que visitaram o site pela primeira vez.',
        sessions: 'N√∫mero total de sess√µes iniciadas neste per√≠odo.',
        engagementRate: 'Percentagem de sess√µes com intera√ß√£o (‚â•10s, convers√£o ou ‚â•2 pageviews).',
        avgDuration: 'Tempo m√©dio de dura√ß√£o das sess√µes.',
        bounceRate: 'Percentagem de sess√µes sem intera√ß√£o (1 - engagement rate).',
      };

      // Initialize Supabase client
      const supabase = window.supabase.createClient(CONFIG.supabase.url, CONFIG.supabase.anonKey);

      // Initialize Day.js plugins
      dayjs.extend(window.dayjs_plugin_utc);
      dayjs.extend(window.dayjs_plugin_timezone);
      dayjs.extend(window.dayjs_plugin_customParseFormat);
      dayjs.tz.setDefault(CONFIG.timezone);

      // ========================================
      // STATE
      // ========================================

      const state = {
        filters: {
          period: '7d',
          dateFrom: null,
          dateTo: null,
          hostname: '',
        },
        datasets: {
          kpisCurrent: [],
          kpisPrevious: [],
          pages: [],
          acquisition: [],
          domainBreakdown: [],
          conversion: [],
          conversionTimeline: [],
        },
        domainSettings: {}, // { 'hostname': true/false }
        tempDomainSettings: {}, // Temporary state for modal
        allDomains: [], // All available domains
        pageSettings: [], // All pages with is_obrigado flag
        tempPageSettings: {}, // Temporary state for modal { 'hostname|page_path': true/false }
        cache: new Map(),
        loading: false,
        activeTab: 'overview',
        lastRefresh: null,
        lastRefreshInWindow: false,
      };

      // Chart instances (to destroy before re-render)
      const charts = {};

      // ========================================
      // FORMATTERS
      // ========================================

      const fmtNumber = (n) => {
        if (n == null) return '‚Äî';
        return new Intl.NumberFormat(CONFIG.locale).format(Math.round(n));
      };

      const fmtPercent = (n) => {
        if (n == null) return '‚Äî';
        return `${(n * 100).toLocaleString(CONFIG.locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%`;
      };

      const fmtDuration = (seconds) => {
        if (seconds == null || seconds === 0) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const fmtDate = (date) => {
        return dayjs(date).format('DD/MM/YYYY');
      };

      const fmtDelta = (current, previous) => {
        if (previous == null || previous === 0) return null;
        return ((current - previous) / previous) * 100;
      };

      // Clean and format source/medium strings
      const cleanSourceMedium = (sourceMedium) => {
        if (!sourceMedium || sourceMedium === 'Unknown') return '(n√£o definido)';
        
        // URL decode: replace + with space and decode %XX
        let cleaned = sourceMedium.replace(/\+/g, ' ').replace(/%([0-9A-F]{2})/gi, (_, hex) => 
          String.fromCharCode(parseInt(hex, 16))
        );
        
        // Check for long numeric IDs (likely campaign IDs)
        if (/^\d{10,}/.test(cleaned)) {
          const match = cleaned.match(/^(\d+)\s*\/\s*(.+)$/);
          if (match) {
            return `Campaign ${match[1].slice(0, 8)}... / ${match[2]}`;
          }
          return `Campaign ${cleaned.slice(0, 12)}...`;
        }
        
        // Map known patterns to friendly names
        const patterns = [
          { regex: /^fb\s*\/\s*paid$/i, label: 'Facebook Ads' },
          { regex: /^ig\s*\/\s*paid$/i, label: 'Instagram Ads' },
          { regex: /^google\s*\/\s*cpc$/i, label: 'Google Ads' },
          { regex: /^google\s*\/\s*organic$/i, label: 'Google (org√¢nico)' },
          { regex: /^bing\s*\/\s*organic$/i, label: 'Bing (org√¢nico)' },
          { regex: /^an\s*\/\s*paid$/i, label: 'An√∫ncios (outras redes)' },
          { regex: /^fb\s*\/\s*(.+)/i, label: (m) => `Facebook / ${m[1]}` },
          { regex: /^ig\s*\/\s*(.+)/i, label: (m) => `Instagram / ${m[1]}` },
          { regex: /^adsmanager\.facebook\.com\s*\/\s*(.+)/i, label: 'Facebook Ads Manager' },
          { regex: /^app\.gohighlevel\.com\s*\/\s*(.+)/i, label: 'GoHighLevel' },
          { regex: /^business\.facebook\.com\s*\/\s*(.+)/i, label: 'Facebook Business' },
          { regex: /^\(direct\)\s*\/\s*\(none\)$/i, label: 'Direto' },
          { regex: /^\(not\s+set\)$/i, label: '(n√£o definido)' },
        ];
        
        for (const pattern of patterns) {
          const match = cleaned.match(pattern.regex);
          if (match) {
            return typeof pattern.label === 'function' ? pattern.label(match) : pattern.label;
          }
        }
        
        // Truncate very long strings
        if (cleaned.length > 60) {
          return cleaned.slice(0, 57) + '...';
        }
        
        return cleaned;
      };

      const cleanChannel = (channel) => {
        if (!channel || channel === 'Unknown') return 'Unassigned';
        
        const mapping = {
          'Organic Social': 'Redes Sociais (Org√¢nico)',
          'Paid Social': 'Redes Sociais (Pago)',
          'Organic Search': 'Pesquisa Org√¢nica',
          'Paid Search': 'Pesquisa Paga',
          'Direct': 'Direto',
          'Referral': 'Refer√™ncia',
          'Email': 'Email',
          'Affiliates': 'Afiliados',
          'Display': 'Display',
          'Paid Other': 'Outro (Pago)',
          'Unassigned': 'N√£o Categorizado'
        };
        
        return mapping[channel] || channel;
      };

      // ========================================
      // UTILS
      // ========================================

      const getActiveDomains = () => {
        return Object.keys(state.domainSettings).filter(h => state.domainSettings[h] === true);
      };

      const getDateRange = (period) => {
        const now = dayjs().tz(CONFIG.timezone);
        let from, to;

        switch (period) {
          case 'today':
            from = to = now.format('YYYY-MM-DD');
            break;
          case 'yesterday':
            from = to = now.subtract(1, 'day').format('YYYY-MM-DD');
            break;
          case '7d':
            from = now.subtract(6, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case '30d':
            from = now.subtract(29, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case '90d':
            from = now.subtract(89, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case 'ytd':
            from = now.startOf('year').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case 'custom':
            from = state.filters.dateFrom || now.subtract(6, 'day').format('YYYY-MM-DD');
            to = state.filters.dateTo || now.format('YYYY-MM-DD');
            break;
          default:
            from = now.subtract(6, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
        }

        return { from, to };
      };

      const getPreviousPeriod = (from, to) => {
        const fromDate = dayjs(from);
        const toDate = dayjs(to);
        const duration = toDate.diff(fromDate, 'day') + 1;

        const prevTo = fromDate.subtract(1, 'day').format('YYYY-MM-DD');
        const prevFrom = fromDate.subtract(duration, 'day').format('YYYY-MM-DD');

        return { from: prevFrom, to: prevTo };
      };

      const sum = (arr, key) => {
        return arr.reduce((acc, item) => acc + (item[key] || 0), 0);
      };

      const weightedAvg = (arr, valueKey, weightKey) => {
        const totalWeight = sum(arr, weightKey);
        if (totalWeight === 0) return 0;
        const weightedSum = arr.reduce((acc, item) => acc + (item[valueKey] || 0) * (item[weightKey] || 0), 0);
        return weightedSum / totalWeight;
      };

      // ========================================
      // FETCH
      // ========================================

      const fetchDailyKPIs = async (from, to, filters = {}) => {
        // Ensure at least 7 days (1 week) of data for the chart
        const fromDate = dayjs(from);
        const toDate = dayjs(to);
        const daysDiff = toDate.diff(fromDate, 'day') + 1;
        
        let adjustedFrom = from;
        if (daysDiff < 7) {
          // Expand the range to show at least 7 days
          adjustedFrom = toDate.subtract(6, 'day').format('YYYY-MM-DD');
        }

        // If hostname filter is applied, query analytics_users_summary with hostname filter
        if (filters.hostname) {
          // Check if domain is active
          if (state.domainSettings[filters.hostname] === false) {
            console.warn(`Domain ${filters.hostname} is disabled`);
            return [];
          }

          let query = supabase
            .from('analytics_users_summary')
            .select('*')
            .gte('date', adjustedFrom)
            .lte('date', to)
            .eq('hostname', filters.hostname)
            .order('date', { ascending: true });

          const { data, error } = await query;
          if (error) throw error;

          console.log('üìä Raw data from Supabase (with hostname filter):', data);

          return (data || []).map((row) => {
            // Normalize engagement_rate: if > 1, it's already percentage; if < 1, it's decimal
            let engRate = row.engagement_rate || 0;
            if (engRate > 0 && engRate <= 1) {
              engRate = engRate; // Keep as decimal (0.83)
            } else if (engRate > 1) {
              engRate = engRate / 100; // Convert percentage to decimal (83 -> 0.83)
            }

          return {
            date: row.date,
            total_users: row.total_users,
            sessions: row.sessions,
            new_users: row.new_users,
            engagement_rate: engRate,
            avg_session_duration: row.avg_session_duration || 0,
            bounce_rate: row.bounce_rate || 0,
          };
          });
        }

        // No filters: aggregate only active domains
        const activeDomains = getActiveDomains();
        
        if (activeDomains.length === 0) {
          console.warn('No active domains');
          return [];
        }

        let query = supabase
          .from('analytics_users_summary')
          .select('*')
          .gte('date', adjustedFrom)
          .lte('date', to)
          .in('hostname', activeDomains)
          .order('date', { ascending: true });

        const { data, error } = await query;
        if (error) throw error;

        console.log('üìä Raw data from Supabase (active domains only):', data);

        // Aggregate by date
        const aggregated = {};
        (data || []).forEach((row) => {
          const dateKey = row.date;
          if (!aggregated[dateKey]) {
            aggregated[dateKey] = {
              date: dateKey,
              total_users: 0,
              sessions: 0,
              new_users: 0,
              _eng_weighted: 0,
              _dur_weighted: 0,
              bounce_rate: 0,
            };
          }
          aggregated[dateKey].total_users += row.total_users || 0;
          aggregated[dateKey].sessions += row.sessions || 0;
          aggregated[dateKey].new_users += row.new_users || 0;
          
          let engRate = row.engagement_rate || 0;
          if (engRate > 1) engRate = engRate / 100;
          
          aggregated[dateKey]._eng_weighted += engRate * (row.sessions || 0);
          aggregated[dateKey]._dur_weighted += (row.avg_session_duration || 0) * (row.sessions || 0);
        });

        return Object.values(aggregated).map((row) => {
          const engRate = row.sessions > 0 ? row._eng_weighted / row.sessions : 0;
          return {
            date: row.date,
            total_users: row.total_users,
            sessions: row.sessions,
            new_users: row.new_users,
            engagement_rate: engRate,
            avg_session_duration: row.sessions > 0 ? row._dur_weighted / row.sessions : 0,
            bounce_rate: 1 - engRate,
          };
        }).sort((a, b) => (a.date > b.date ? 1 : -1));
      };

      const fetchPages = async (from, to, filters = {}) => {
        // Fetch from analytics_core and aggregate by page
        let query = supabase
          .from('analytics_core')
          .select('page_path, hostname, unique_users, sessions, new_users, avg_session_duration, engagement_rate, bounce_rate')
          .gte('date', from)
          .lte('date', to);

        // Apply hostname filter if set
        if (filters.hostname) {
          if (state.domainSettings[filters.hostname] === false) {
            return [];
          }
          query = query.eq('hostname', filters.hostname);
        } else {
          // Only active domains
          const activeDomains = getActiveDomains();
          if (activeDomains.length === 0) return [];
          query = query.in('hostname', activeDomains);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate by page_path
        const aggregated = {};
        (data || []).forEach((row) => {
          const key = row.page_path;
          if (!aggregated[key]) {
            aggregated[key] = {
              page_path: key,
              unique_users: 0,
              sessions: 0,
              new_users: 0,
              _eng_weighted: 0,
              _dur_weighted: 0,
              _bounce_weighted: 0,
            };
          }
          aggregated[key].unique_users += row.unique_users || 0;
          aggregated[key].sessions += row.sessions || 0;
          aggregated[key].new_users += row.new_users || 0;
          aggregated[key]._eng_weighted += (row.engagement_rate || 0) * (row.sessions || 0);
          aggregated[key]._dur_weighted += (row.avg_session_duration || 0) * (row.sessions || 0);
          aggregated[key]._bounce_weighted += (row.bounce_rate || 0) * (row.sessions || 0);
        });

        return Object.values(aggregated).map((page) => {
          const engRate = page.sessions > 0 ? page._eng_weighted / page.sessions : 0;
          return {
            ...page,
            engagement_rate: engRate,
            avg_session_duration: page.sessions > 0 ? page._dur_weighted / page.sessions : 0,
            bounce_rate: 1 - engRate, // Calculate from engagement_rate instead of DB field
          };
        }).sort((a, b) => b.sessions - a.sessions);
      };

      const fetchAcquisition = async (from, to, filters = {}) => {
        // Fetch acquisition data and aggregate
        let query = supabase
          .from('analytics_acquisition')
          .select('hostname, session_source_medium, session_channel_group, unique_users, sessions, engagement_rate')
          .gte('date', from)
          .lte('date', to);

        // Apply hostname filter if set
        if (filters.hostname) {
          if (state.domainSettings[filters.hostname] === false) {
            return [];
          }
          query = query.eq('hostname', filters.hostname);
        } else {
          // Only active domains
          const activeDomains = getActiveDomains();
          if (activeDomains.length === 0) return [];
          query = query.in('hostname', activeDomains);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate by channel/source
        const aggregated = {};
        (data || []).forEach((row) => {
          const key = `${row.session_channel_group || 'Unknown'}-${row.session_source_medium || 'Unknown'}`;
          if (!aggregated[key]) {
            aggregated[key] = {
              channel: row.session_channel_group || 'Unknown',
              source_medium: row.session_source_medium || 'Unknown',
              unique_users: 0,
              sessions: 0,
              _eng_weighted: 0,
            };
          }
          aggregated[key].unique_users += row.unique_users || 0;
          aggregated[key].sessions += row.sessions || 0;
          aggregated[key]._eng_weighted += (row.engagement_rate || 0) * (row.sessions || 0);
        });

        return Object.values(aggregated).map((item) => ({
          ...item,
          engagement_rate: item.sessions > 0 ? item._eng_weighted / item.sessions : 0,
        })).sort((a, b) => b.sessions - a.sessions);
      };

      const fetchFilterOptions = async () => {
        // Fetch unique hostnames for dropdown (only active ones)
        const activeDomains = getActiveDomains();
        
        if (activeDomains.length === 0) {
          return { hostnames: [] };
        }

        const { data: hostnames } = await supabase
          .from('analytics_core')
          .select('hostname')
          .not('hostname', 'is', null)
          .in('hostname', activeDomains)
          .order('hostname');

        const uniqueHostnames = [...new Set(hostnames?.map((h) => h.hostname) || [])];

        return { hostnames: uniqueHostnames };
      };

      const fetchAllHostnames = async () => {
        // Fetch ALL unique hostnames from all tables (for settings)
        const [coreData, summaryData, acquisitionData] = await Promise.all([
          supabase.from('analytics_core').select('hostname').not('hostname', 'is', null),
          supabase.from('analytics_users_summary').select('hostname').not('hostname', 'is', null),
          supabase.from('analytics_acquisition').select('hostname').not('hostname', 'is', null),
        ]);

        const allHostnames = new Set();
        
        coreData.data?.forEach(row => allHostnames.add(row.hostname));
        summaryData.data?.forEach(row => allHostnames.add(row.hostname));
        acquisitionData.data?.forEach(row => allHostnames.add(row.hostname));

        // Remove 'global' if present
        allHostnames.delete('global');

        return [...allHostnames].sort();
      };

      const fetchDomainBreakdown = async (from, to) => {
        const activeDomains = getActiveDomains();
        
        if (activeDomains.length === 0) return [];

        let query = supabase
          .from('analytics_users_summary')
          .select('hostname, total_users, sessions, new_users')
          .gte('date', from)
          .lte('date', to)
          .in('hostname', activeDomains);

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate by hostname
        const aggregated = {};
        (data || []).forEach((row) => {
          const hostname = row.hostname;
          if (!aggregated[hostname]) {
            aggregated[hostname] = {
              hostname,
              total_users: 0,
              sessions: 0,
              new_users: 0,
            };
          }
          aggregated[hostname].total_users += row.total_users || 0;
          aggregated[hostname].sessions += row.sessions || 0;
          aggregated[hostname].new_users += row.new_users || 0;
        });

        return Object.values(aggregated).sort((a, b) => b.sessions - a.sessions);
      };

      const fetchPageSettings = async () => {
        const { data, error } = await supabase
          .from('page_settings')
          .select('*')
          .order('hostname')
          .order('page_path');

        if (error) throw error;
        return data || [];
      };

      const updatePageSetting = async (hostname, pagePath, isObrigado) => {
        const { error } = await supabase
          .from('page_settings')
          .update({ is_obrigado: isObrigado })
          .eq('hostname', hostname)
          .eq('page_path', pagePath);

        if (error) throw error;
      };

      const fetchConversionData = async (from, to, filters = {}) => {
        // Get obrigado pages
        const obrigadoPages = state.pageSettings.filter(p => p.is_obrigado);
        
        if (obrigadoPages.length === 0) return [];

        // Build query for analytics_core filtered by obrigado pages
        let query = supabase
          .from('analytics_core')
          .select('hostname, page_path, date, unique_users, sessions, new_users, avg_session_duration, engagement_rate')
          .gte('date', from)
          .lte('date', to);

        // Apply hostname filter if set
        if (filters.hostname) {
          if (state.domainSettings[filters.hostname] === false) {
            return [];
          }
          query = query.eq('hostname', filters.hostname);
        } else {
          // Only active domains
          const activeDomains = getActiveDomains();
          if (activeDomains.length === 0) return [];
          query = query.in('hostname', activeDomains);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Filter only obrigado pages
        const obrigadoSet = new Set(obrigadoPages.map(p => `${p.hostname}|${p.page_path}`));
        const filtered = (data || []).filter(row => 
          obrigadoSet.has(`${row.hostname}|${row.page_path}`)
        );

        return filtered;
      };

      // ========================================
      // COMPUTE
      // ========================================

      const computeKPIs = (kpisData) => {
        const totalUsers = sum(kpisData, 'total_users');
        const newUsers = sum(kpisData, 'new_users');
        const sessions = sum(kpisData, 'sessions');
        const engagementRate = weightedAvg(kpisData, 'engagement_rate', 'sessions');
        const avgDuration = weightedAvg(kpisData, 'avg_session_duration', 'sessions');
        
        // Calculate bounce rate as 1 - engagement_rate (field bounce_rate is always 0 in DB)
        const bounceRate = 1 - engagementRate;

        return {
          totalUsers,
          newUsers,
          sessions,
          engagementRate,
          avgDuration,
          bounceRate,
        };
      };


      // ========================================
      // RENDER
      // ========================================

      const renderKPICards = (current, previous) => {
        const kpis = [
          {
            label: 'Total Users',
            value: current.totalUsers,
            prev: previous.totalUsers,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.totalUsers,
          },
          {
            label: 'New Users',
            value: current.newUsers,
            prev: previous.newUsers,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.newUsers,
          },
          {
            label: 'Sessions',
            value: current.sessions,
            prev: previous.sessions,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.sessions,
          },
          {
            label: 'Engagement Rate',
            value: current.engagementRate,
            prev: previous.engagementRate,
            format: fmtPercent,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.engagementRate,
          },
          {
            label: 'Avg. Duration',
            value: current.avgDuration,
            prev: previous.avgDuration,
            format: fmtDuration,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.avgDuration,
          },
          {
            label: 'Bounce Rate',
            value: current.bounceRate,
            prev: previous.bounceRate,
            format: fmtPercent,
            invertDelta: true, // Lower is better
            tooltip: METRIC_DESCRIPTIONS.bounceRate,
          },
        ];

        const html = kpis
          .map((kpi) => {
            const delta = fmtDelta(kpi.value, kpi.prev);
            const deltaClass =
              delta == null
                ? ''
                : delta > 0
                ? kpi.invertDelta
                  ? 'delta-negative'
                  : 'delta-positive'
                : kpi.invertDelta
                ? 'delta-positive'
                : 'delta-negative';
            const deltaIcon = delta == null ? '' : delta > 0 ? '‚Üë' : '‚Üì';
            const deltaText =
              delta == null
                ? ''
                : `${deltaIcon} ${Math.abs(delta).toLocaleString(CONFIG.locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%`;

            return `
            <div class="card rounded-lg p-4">
              <div class="flex items-center gap-1 text-sm text-gray-400 mb-1">
                <span>${kpi.label}</span>
                <span class="tooltip-icon" title="${kpi.tooltip}">‚ÑπÔ∏è</span>
              </div>
              <div class="text-2xl font-bold mb-1">${kpi.format(kpi.value)}</div>
              <div class="text-xs ${deltaClass}">${deltaText || '‚Äî'}</div>
            </div>
          `;
          })
          .join('');

        document.getElementById('kpi-cards').innerHTML = html;
      };

      const renderOverviewChart = (kpisData) => {
        const ctx = document.getElementById('chart-overview-timeline');
        if (!ctx) return;

        // Destroy previous chart
        if (charts.overview) charts.overview.destroy();

        // Prepare data by date
        const sorted = kpisData.sort((a, b) => (a.date > b.date ? 1 : -1));

        const labels = sorted.map((d) => fmtDate(d.date));
        const sessions = sorted.map((d) => d.sessions);
        const users = sorted.map((d) => d.total_users); // Fix: use snake_case
        const engagement = sorted.map((d) => (d.engagement_rate || 0) * 100); // Fix: use snake_case

        // Debug log
        console.log('üìä Chart Data:', { sessions, users, engagement, kpisData });

        const datasets = [
          {
            label: 'Sessions',
            data: sessions,
            borderColor: CONFIG.colors.primary,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
          {
            label: 'Users',
            data: users,
            borderColor: CONFIG.colors.success,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
          {
            label: 'Engagement Rate (%)',
            data: engagement,
            borderColor: CONFIG.colors.warning,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y1',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
        ];

        charts.overview = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            layout: {
              padding: {
                top: 10,
                right: 10,
                bottom: 10,
                left: 10,
              },
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                align: 'end',
                labels: { 
                  color: '#e5e5e5',
                  padding: 15,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  filter: (item) => {
                    // Remove duplicates: show only current period labels
                    return !item.text.includes('(anterior)');
                  }
                },
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                padding: 12,
                displayColors: true,
                callbacks: {
                  label: (context) => {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      if (context.dataset.yAxisID === 'y1') {
                        label += context.parsed.y.toFixed(1) + '%';
                      } else {
                        label += context.parsed.y.toLocaleString('pt-PT');
                      }
                    }
                    return label;
                  }
                },
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                type: 'linear',
                position: 'left',
                beginAtZero: true,
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
                title: {
                  display: true,
                  text: 'Sessions / Users',
                  color: '#9ca3af',
                },
              },
              y1: {
                type: 'linear',
                position: 'right',
                min: 0,
                max: 100,
                ticks: { 
                  color: '#9ca3af',
                  callback: (value) => `${value}%`,
                },
                grid: { display: false },
                title: {
                  display: true,
                  text: 'Engagement Rate',
                  color: '#f59e0b',
                },
              },
            },
          },
        });
      };

      const renderPagesTable = (pages) => {
        const tbody = document.querySelector('#table-pages tbody');
        if (!tbody) return;

        const html = pages
          .slice(0, 20) // Top 20
          .map((page) => {
            return `
            <tr>
              <td class="font-mono text-sm">${page.page_path}</td>
              <td>${fmtNumber(page.sessions)}</td>
              <td>${fmtNumber(page.unique_users)}</td>
              <td>${fmtDuration(page.avg_session_duration)}</td>
              <td>${fmtPercent(page.engagement_rate)}</td>
              <td>${fmtPercent(page.bounce_rate)}</td>
            </tr>
          `;
          })
          .join('');

        tbody.innerHTML = html || '<tr><td colspan="6" class="text-center text-gray-500">Sem dados</td></tr>';
      };

      const renderPagesBarChart = (pages) => {
        const ctx = document.getElementById('chart-pages-bar');
        if (!ctx) return;

        if (charts.pagesBar) charts.pagesBar.destroy();

        const top10 = pages.slice(0, 10);
        const labels = top10.map((p) => p.page_path);
        const data = top10.map((p) => p.sessions);

        charts.pagesBar = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Sessions',
                data,
                backgroundColor: CONFIG.colors.primary,
              },
            ],
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                ticks: { color: '#9ca3af', font: { size: 10 } },
                grid: { display: false },
              },
            },
          },
        });
      };

      const renderDomainBreakdownChart = (domainData) => {
        const ctx = document.getElementById('chart-domains-breakdown');
        if (!ctx) return;

        if (charts.domainBreakdown) charts.domainBreakdown.destroy();

        const labels = domainData.map(d => d.hostname);
        const sessions = domainData.map(d => d.sessions);
        const users = domainData.map(d => d.total_users);

        // Generate colors for each domain
        const colors = [
          '#3b82f6', '#10b981', '#f59e0b', '#ef4444', 
          '#8b5cf6', '#ec4899', '#06b6d4', '#f97316'
        ];

        charts.domainBreakdown = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Sessions',
                data: sessions,
                backgroundColor: CONFIG.colors.primary,
                borderRadius: 4,
              },
              {
                label: 'Users',
                data: users,
                backgroundColor: CONFIG.colors.success,
                borderRadius: 4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                align: 'end',
                labels: { 
                  color: '#e5e5e5',
                  padding: 15,
                  usePointStyle: true,
                },
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                padding: 12,
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
                beginAtZero: true,
              },
            },
          },
        });
      };


      const renderAcquisitionTable = (acquisition) => {
        const tbody = document.querySelector('#table-acquisition tbody');
        if (!tbody) return;

        const html = acquisition
          .map((row) => {
            const channelClean = cleanChannel(row.channel);
            const sourceClean = cleanSourceMedium(row.source_medium);
            
            return `
            <tr>
              <td>
                <span title="${row.channel}">${channelClean}</span>
              </td>
              <td class="text-sm">
                <span title="${row.source_medium}" class="cursor-help">${sourceClean}</span>
              </td>
              <td>${fmtNumber(row.sessions)}</td>
              <td>${fmtNumber(row.unique_users)}</td>
              <td>${fmtPercent(row.engagement_rate)}</td>
            </tr>
          `;
          })
          .join('');

        tbody.innerHTML = html || '<tr><td colspan="5" class="text-center text-gray-500">Sem dados</td></tr>';
      };

      const renderAcquisitionDonutChart = (acquisition) => {
        const ctx = document.getElementById('chart-acquisition-donut');
        if (!ctx) return;

        if (charts.acquisitionDonut) charts.acquisitionDonut.destroy();

        // Group by channel (aggregate multiple sources)
        const channelGroups = {};
        acquisition.forEach((row) => {
          const channelKey = row.channel || 'Unknown';
          if (!channelGroups[channelKey]) {
            channelGroups[channelKey] = {
              channel: channelKey,
              sessions: 0,
              sources: []
            };
          }
          channelGroups[channelKey].sessions += row.sessions || 0;
          channelGroups[channelKey].sources.push(row.source_medium);
        });

        const grouped = Object.values(channelGroups).sort((a, b) => b.sessions - a.sessions);
        const labels = grouped.map((g) => cleanChannel(g.channel));
        const data = grouped.map((g) => g.sessions);

        charts.acquisitionDonut = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [
              {
                data,
                backgroundColor: [
                  CONFIG.colors.primary,
                  CONFIG.colors.success,
                  CONFIG.colors.warning,
                  CONFIG.colors.danger,
                  '#8b5cf6',
                  '#ec4899',
                  '#f97316',
                  '#06b6d4',
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                labels: { color: '#e5e5e5', padding: 12 },
                position: 'bottom',
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${context.label}: ${value.toLocaleString('pt-PT')} (${percentage}%)`;
                  }
                }
              },
            },
          },
        });
      };

      const showEmptyState = (show) => {
        const empty = document.getElementById('acquisition-empty');
        const content = document.getElementById('acquisition-content');
        if (show) {
          empty.classList.remove('hidden');
          content.classList.add('hidden');
        } else {
          empty.classList.add('hidden');
          content.classList.remove('hidden');
        }
      };

      const renderConversionKPIs = (conversionData) => {
        const totalSessions = sum(conversionData, 'sessions');
        const totalUsers = sum(conversionData, 'unique_users');
        const engagementRate = weightedAvg(conversionData, 'engagement_rate', 'sessions');

        document.getElementById('conversion-total-sessions').textContent = fmtNumber(totalSessions);
        document.getElementById('conversion-total-users').textContent = fmtNumber(totalUsers);
        document.getElementById('conversion-engagement-rate').textContent = fmtPercent(engagementRate);
      };

      const renderConversionTimeline = (conversionData) => {
        const ctx = document.getElementById('chart-conversion-timeline');
        if (!ctx) return;

        if (charts.conversionTimeline) charts.conversionTimeline.destroy();

        // Aggregate by date
        const byDate = {};
        conversionData.forEach(row => {
          if (!byDate[row.date]) {
            byDate[row.date] = { sessions: 0, users: 0 };
          }
          byDate[row.date].sessions += row.sessions || 0;
          byDate[row.date].users += row.unique_users || 0;
        });

        const sorted = Object.keys(byDate).sort().map(date => ({
          date,
          ...byDate[date]
        }));

        const labels = sorted.map(d => fmtDate(d.date));
        const sessions = sorted.map(d => d.sessions);
        const users = sorted.map(d => d.users);

        charts.conversionTimeline = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: 'Convers√µes (Sessions)',
                data: sessions,
                borderColor: CONFIG.colors.success,
                backgroundColor: 'transparent',
                borderWidth: 3,
                tension: 0.4,
                pointRadius: 4,
                pointHoverRadius: 6,
              },
              {
                label: 'Utilizadores',
                data: users,
                borderColor: CONFIG.colors.primary,
                backgroundColor: 'transparent',
                borderWidth: 3,
                tension: 0.4,
                pointRadius: 4,
                pointHoverRadius: 6,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                align: 'end',
                labels: { color: '#e5e5e5', padding: 15, usePointStyle: true },
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                padding: 12,
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                beginAtZero: true,
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
            },
          },
        });
      };

      const renderConversionPagesTable = (conversionData) => {
        const tbody = document.querySelector('#table-conversion-pages tbody');
        if (!tbody) return;

        // Aggregate by page
        const byPage = {};
        conversionData.forEach(row => {
          const key = `${row.hostname}${row.page_path}`;
          if (!byPage[key]) {
            byPage[key] = {
              hostname: row.hostname,
              page_path: row.page_path,
              sessions: 0,
              users: 0,
              _eng_weighted: 0,
            };
          }
          byPage[key].sessions += row.sessions || 0;
          byPage[key].users += row.unique_users || 0;
          byPage[key]._eng_weighted += (row.engagement_rate || 0) * (row.sessions || 0);
        });

        const pages = Object.values(byPage).map(p => ({
          ...p,
          engagement_rate: p.sessions > 0 ? p._eng_weighted / p.sessions : 0,
        })).sort((a, b) => b.sessions - a.sessions);

        const html = pages.slice(0, 10).map(page => `
          <tr>
            <td>
              <div class="text-xs text-gray-500">${page.hostname}</div>
              <div class="font-mono text-sm">${page.page_path}</div>
            </td>
            <td>${fmtNumber(page.sessions)}</td>
            <td>${fmtNumber(page.users)}</td>
            <td>${fmtPercent(page.engagement_rate)}</td>
          </tr>
        `).join('');

        tbody.innerHTML = html || '<tr><td colspan="4" class="text-center text-gray-500">Sem dados</td></tr>';
      };

      const renderConversionDomainsChart = (conversionData) => {
        const ctx = document.getElementById('chart-conversion-domains');
        if (!ctx) return;

        if (charts.conversionDomains) charts.conversionDomains.destroy();

        // Aggregate by hostname
        const byDomain = {};
        conversionData.forEach(row => {
          if (!byDomain[row.hostname]) {
            byDomain[row.hostname] = 0;
          }
          byDomain[row.hostname] += row.sessions || 0;
        });

        const sorted = Object.entries(byDomain).sort((a, b) => b[1] - a[1]);
        const labels = sorted.map(([hostname]) => hostname);
        const data = sorted.map(([, sessions]) => sessions);

        charts.conversionDomains = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: [
                CONFIG.colors.success, CONFIG.colors.primary, CONFIG.colors.warning,
                CONFIG.colors.danger, '#8b5cf6', '#ec4899', '#06b6d4', '#f97316'
              ],
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                labels: { color: '#e5e5e5', padding: 12 },
                position: 'bottom',
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
              },
            },
          },
        });
      };


      // ========================================
      // EVENTS
      // ========================================

      const updateFilters = () => {
        const period = document.getElementById('filter-period').value;
        const hostname = document.getElementById('filter-hostname').value;

        state.filters.period = period;
        state.filters.hostname = hostname;

        // Show/hide custom date inputs
        const customRange = document.getElementById('custom-range');
        if (period === 'custom') {
          customRange.classList.remove('hidden');
        } else {
          customRange.classList.add('hidden');
        }

        saveFiltersToLocalStorage();
        updateQueryParams();
      };

      const saveFiltersToLocalStorage = () => {
        localStorage.setItem('boomlab-filters', JSON.stringify(state.filters));
      };

      const loadFiltersFromLocalStorage = () => {
        const saved = localStorage.getItem('boomlab-filters');
        if (saved) {
          const parsed = JSON.parse(saved);
          state.filters = { ...state.filters, ...parsed };
        }
      };

      const saveDomainSettingsToLocalStorage = () => {
        localStorage.setItem('boomlab-domain-settings', JSON.stringify(state.domainSettings));
      };

      const loadDomainSettingsFromLocalStorage = () => {
        const saved = localStorage.getItem('boomlab-domain-settings');
        if (saved) {
          try {
            state.domainSettings = JSON.parse(saved);
          } catch (e) {
            console.error('Error parsing domain settings:', e);
            state.domainSettings = {};
          }
        }
      };

      const updateQueryParams = () => {
        const params = new URLSearchParams();
        if (state.filters.period) params.set('period', state.filters.period);
        if (state.filters.hostname) params.set('hostname', state.filters.hostname);
        if (state.activeTab) params.set('tab', state.activeTab);

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newUrl);
      };

      const loadFiltersFromQueryParams = () => {
        const params = new URLSearchParams(window.location.search);
        if (params.has('period')) state.filters.period = params.get('period');
        if (params.has('hostname')) state.filters.hostname = params.get('hostname');
        if (params.has('tab')) state.activeTab = params.get('tab');
      };

      const applyFiltersToUI = () => {
        document.getElementById('filter-period').value = state.filters.period || '7d';
        document.getElementById('filter-hostname').value = state.filters.hostname || '';

        // Show custom range if needed
        if (state.filters.period === 'custom') {
          document.getElementById('custom-range').classList.remove('hidden');
          if (state.filters.dateFrom) document.getElementById('filter-date-from').value = state.filters.dateFrom;
          if (state.filters.dateTo) document.getElementById('filter-date-to').value = state.filters.dateTo;
        }
      };

      const switchTab = (tabName) => {
        state.activeTab = tabName;

        // Update tab UI
        document.querySelectorAll('.tab').forEach((tab) => {
          tab.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

        // Show/hide content
        document.querySelectorAll('.tab-content').forEach((content) => {
          content.classList.add('hidden');
        });
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');

        updateQueryParams();
        renderTabContent(tabName);
      };

      const renderTabContent = (tabName) => {
        switch (tabName) {
          case 'overview':
            renderOverviewChart(state.datasets.kpisCurrent);
            break;
          case 'pages':
            // Show/hide domain breakdown based on filter
            const showBreakdown = !state.filters.hostname && state.datasets.domainBreakdown.length > 1;
            const breakdownEl = document.getElementById('pages-domain-breakdown');
            
            if (showBreakdown) {
              breakdownEl.classList.remove('hidden');
              renderDomainBreakdownChart(state.datasets.domainBreakdown);
            } else {
              breakdownEl.classList.add('hidden');
            }

            renderPagesTable(state.datasets.pages);
            renderPagesBarChart(state.datasets.pages);
            break;
          case 'acquisition':
            if (state.datasets.acquisition.length === 0) {
              showEmptyState(true);
            } else {
              showEmptyState(false);
              renderAcquisitionTable(state.datasets.acquisition);
              renderAcquisitionDonutChart(state.datasets.acquisition);
            }
            break;
          case 'conversion':
            const hasObrigadoPages = state.pageSettings.some(p => p.is_obrigado);
            const conversionEmpty = document.getElementById('conversion-empty');
            const conversionContent = document.getElementById('conversion-content');
            
            if (!hasObrigadoPages || state.datasets.conversion.length === 0) {
              conversionEmpty.classList.remove('hidden');
              conversionContent.classList.add('hidden');
            } else {
              conversionEmpty.classList.add('hidden');
              conversionContent.classList.remove('hidden');
              renderConversionKPIs(state.datasets.conversion);
              renderConversionTimeline(state.datasets.conversion);
              renderConversionPagesTable(state.datasets.conversion);
              renderConversionDomainsChart(state.datasets.conversion);
            }
            break;
        }
      };

      // ========================================
      // FETCH ALL DATA
      // ========================================

      const fetchAllData = async (forceRefresh = false) => {
        if (state.loading) return;

        state.loading = true;
        document.getElementById('btn-refresh').disabled = true;

        try {
          // Get date range
          const { from, to } = getDateRange(state.filters.period);
          const previous = getPreviousPeriod(from, to);

          const filters = {
            hostname: state.filters.hostname,
          };

          // Fetch current + previous period + pages + acquisition + conversion in parallel
          // Also fetch domain breakdown if "Todos os dom√≠nios" is selected
          const promises = [
            fetchDailyKPIs(from, to, filters),
            fetchDailyKPIs(previous.from, previous.to, filters),
            fetchPages(from, to, filters),
            fetchAcquisition(from, to, filters),
            fetchConversionData(from, to, filters),
          ];

          // Add domain breakdown only when no hostname filter
          if (!state.filters.hostname) {
            promises.push(fetchDomainBreakdown(from, to));
          }

          const results = await Promise.all(promises);
          const [kpisCurrentFull, kpisPreviousFull, pages, acquisition, conversion, domainBreakdown] = results;

          // Filter data to EXACT period for KPI calculation (not expanded)
          const kpisCurrent = kpisCurrentFull.filter(d => d.date >= from && d.date <= to);
          const kpisPrevious = kpisPreviousFull.filter(d => d.date >= previous.from && d.date <= previous.to);

          // Update state (use full data for chart, filtered for KPIs)
          state.datasets.kpisCurrent = kpisCurrentFull; // Full data for chart with min 7 days
          state.datasets.kpisPrevious = kpisPreviousFull;
          state.datasets.pages = pages;
          state.datasets.acquisition = acquisition;
          state.datasets.conversion = conversion || [];
          state.datasets.domainBreakdown = domainBreakdown || [];

          // Compute KPIs using ONLY the filtered period data
          const currentKPIs = computeKPIs(kpisCurrent);
          const previousKPIs = computeKPIs(kpisPrevious);

          // Render
          renderKPICards(currentKPIs, previousKPIs);
          renderTabContent(state.activeTab);

          // Update last refresh time
          state.lastRefresh = dayjs().tz(CONFIG.timezone);
          document.getElementById('last-update').textContent = state.lastRefresh.format('HH:mm');
        } catch (error) {
          console.error('Error fetching data:', error);
          alert('Erro ao carregar dados. Verifica a consola para detalhes.');
        } finally {
          state.loading = false;
          document.getElementById('btn-refresh').disabled = false;
        }
      };

      const openSettingsModal = async () => {
        // Clone current settings to temp
        state.tempDomainSettings = { ...state.domainSettings };
        
        // Clone page settings
        state.tempPageSettings = {};
        state.pageSettings.forEach(p => {
          state.tempPageSettings[`${p.hostname}|${p.page_path}`] = p.is_obrigado;
        });

        // Show modal
        document.getElementById('settings-modal').classList.remove('hidden');

        // Render domains (default tab)
        await renderDomainsList();
      };

      const closeSettingsModal = () => {
        document.getElementById('settings-modal').classList.add('hidden');
      };

      const saveSettingsModal = async () => {
        // Save domain settings
        state.domainSettings = { ...state.tempDomainSettings };
        saveDomainSettingsToLocalStorage();
        
        // Save page settings to Supabase
        const updates = [];
        for (const [key, isObrigado] of Object.entries(state.tempPageSettings)) {
          const [hostname, pagePath] = key.split('|');
          const current = state.pageSettings.find(p => p.hostname === hostname && p.page_path === pagePath);
          
          if (current && current.is_obrigado !== isObrigado) {
            updates.push(updatePageSetting(hostname, pagePath, isObrigado));
          }
        }

        if (updates.length > 0) {
          try {
            await Promise.all(updates);
            // Reload page settings
            state.pageSettings = await fetchPageSettings();
          } catch (error) {
            console.error('Error saving page settings:', error);
            alert('Erro ao guardar configura√ß√µes de p√°ginas');
            return;
          }
        }
        
        // Close modal
        closeSettingsModal();

        // Reset hostname filter if current one is now disabled
        if (state.filters.hostname && state.domainSettings[state.filters.hostname] === false) {
          state.filters.hostname = '';
          document.getElementById('filter-hostname').value = '';
        }

        // Refresh data and dropdown
        populateFilterOptions().then(() => {
          applyFiltersToUI();
          fetchAllData(true);
        });
      };

      const renderDomainsList = async () => {
        const container = document.getElementById('domains-list');
        
        if (state.allDomains.length === 0) {
          container.innerHTML = '<div class="text-center text-gray-500 py-8">Nenhum dom√≠nio encontrado</div>';
          return;
        }

        const activeCount = Object.values(state.tempDomainSettings).filter(v => v === true).length;
        document.getElementById('domains-count-active').textContent = activeCount;
        document.getElementById('domains-count-total').textContent = state.allDomains.length;

        const html = state.allDomains.map((hostname) => {
          const isActive = state.tempDomainSettings[hostname] !== false;
          const rowClass = isActive ? '' : 'disabled';
          
          return `
            <div class="domain-row ${rowClass}">
              <div>
                <div class="font-mono text-sm">${hostname}</div>
              </div>
              <label class="switch">
                <input type="checkbox" ${isActive ? 'checked' : ''} data-hostname="${hostname}">
                <span class="slider"></span>
              </label>
            </div>
          `;
        }).join('');

        container.innerHTML = html;

        // Add event listeners to switches
        container.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
          checkbox.addEventListener('change', (e) => {
            const hostname = e.target.dataset.hostname;
            state.tempDomainSettings[hostname] = e.target.checked;
            
            // Update row style
            const row = e.target.closest('.domain-row');
            if (e.target.checked) {
              row.classList.remove('disabled');
            } else {
              row.classList.add('disabled');
            }

            // Update counts
            const activeCount = Object.values(state.tempDomainSettings).filter(v => v === true).length;
            document.getElementById('domains-count-active').textContent = activeCount;
          });
        });
      };

      const renderPagesList = async () => {
        const container = document.getElementById('pages-list');
        
        if (state.pageSettings.length === 0) {
          container.innerHTML = '<div class="text-center text-gray-500 py-8">Nenhuma p√°gina encontrada</div>';
          return;
        }

        // Group by hostname
        const grouped = {};
        state.pageSettings.forEach(page => {
          if (!grouped[page.hostname]) {
            grouped[page.hostname] = [];
          }
          grouped[page.hostname].push(page);
        });

        let html = '';
        for (const [hostname, pages] of Object.entries(grouped).sort()) {
          html += `
            <div class="mb-4">
              <div class="text-sm font-semibold text-gray-300 mb-2 px-2">${hostname}</div>
              <div class="space-y-1">
          `;

          pages.forEach(page => {
            const key = `${page.hostname}|${page.page_path}`;
            const isChecked = state.tempPageSettings[key] === true;
            const rowClass = isChecked ? 'page-row is-obrigado' : 'page-row';

            html += `
              <div class="${rowClass}">
                <div class="flex-1">
                  <span class="font-mono text-xs">${page.page_path}</span>
                </div>
                <label class="flex items-center gap-2 cursor-pointer">
                  <input 
                    type="checkbox" 
                    class="checkbox-obrigado" 
                    data-page-key="${key}"
                    ${isChecked ? 'checked' : ''}
                  />
                  <span class="text-xs text-gray-400">Obrigado</span>
                </label>
              </div>
            `;
          });

          html += `
              </div>
            </div>
          `;
        }

        container.innerHTML = html;

        // Add event listeners
        container.querySelectorAll('.checkbox-obrigado').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            const key = e.target.dataset.pageKey;
            state.tempPageSettings[key] = e.target.checked;

            // Update row style
            const row = e.target.closest('.page-row');
            if (e.target.checked) {
              row.classList.add('is-obrigado');
            } else {
              row.classList.remove('is-obrigado');
            }
          });
        });
      };

      const switchSettingsTab = (tabName) => {
        // Update tabs
        document.querySelectorAll('.settings-tab').forEach(tab => {
          tab.classList.remove('active');
          tab.style.color = '#9ca3af';
          tab.style.borderBottomColor = 'transparent';
        });
        const activeTab = document.querySelector(`[data-settings-tab="${tabName}"]`);
        if (activeTab) {
          activeTab.classList.add('active');
          activeTab.style.color = '#3b82f6';
          activeTab.style.borderBottomColor = '#3b82f6';
        }

        // Show/hide content
        document.querySelectorAll('.settings-tab-content').forEach(content => {
          content.classList.add('hidden');
        });
        const activeContent = document.getElementById(`settings-tab-${tabName}`);
        if (activeContent) {
          activeContent.classList.remove('hidden');
        }

        // Render content if needed
        if (tabName === 'pages') {
          renderPagesList();
        }
      };

      const populateFilterOptions = async () => {
        const { hostnames } = await fetchFilterOptions();

        const hostnameSelect = document.getElementById('filter-hostname');
        // Clear existing options except first one
        hostnameSelect.innerHTML = '<option value="">Todos os dom√≠nios</option>';
        
        hostnames.forEach((hostname) => {
          const option = document.createElement('option');
          option.value = hostname;
          option.textContent = hostname;
          hostnameSelect.appendChild(option);
        });
      };

      // ========================================
      // AUTO-REFRESH
      // ========================================

      const setupAutoRefresh = () => {
        // Auto-refresh every 2 hours
        setInterval(() => {
          console.log('[Auto-refresh] 2h interval');
          fetchAllData(true);
        }, 2 * 60 * 60 * 1000);

        // Special trigger: odd hour + minute 55-59
        setInterval(() => {
          const now = dayjs().tz(CONFIG.timezone);
          const minute = now.minute();
          const hour = now.hour();

          // Odd hours: 1, 3, 5, ..., 23
          if (hour % 2 === 1 && minute >= 55 && minute <= 59) {
            if (!state.lastRefreshInWindow) {
              console.log('[Auto-refresh] Special trigger at', now.format('HH:mm'));
              fetchAllData(true);
              state.lastRefreshInWindow = true;
            }
          } else {
            state.lastRefreshInWindow = false;
          }
        }, 60 * 1000); // Check every minute
      };

      // ========================================
      // INIT
      // ========================================

      const init = async () => {
        // Load domain settings first
        loadDomainSettingsFromLocalStorage();

        // Fetch all available domains
        state.allDomains = await fetchAllHostnames();

        // Initialize domain settings for new domains (default: all active)
        state.allDomains.forEach((hostname) => {
          if (state.domainSettings[hostname] === undefined) {
            state.domainSettings[hostname] = true;
          }
        });
        saveDomainSettingsToLocalStorage();

        // Load page settings from Supabase
        state.pageSettings = await fetchPageSettings();

        // Load filters
        loadFiltersFromLocalStorage();
        loadFiltersFromQueryParams();

        // Populate filter dropdowns
        await populateFilterOptions();

        // Apply filters to UI
        applyFiltersToUI();

        // Fetch data
        await fetchAllData();

        // Setup auto-refresh
        setupAutoRefresh();

        // Switch to active tab
        switchTab(state.activeTab);

        // Event listeners
        document.getElementById('filter-period').addEventListener('change', () => {
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-hostname').addEventListener('change', () => {
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-date-from').addEventListener('change', () => {
          state.filters.dateFrom = document.getElementById('filter-date-from').value;
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-date-to').addEventListener('change', () => {
          state.filters.dateTo = document.getElementById('filter-date-to').value;
          updateFilters();
          fetchAllData();
        });

        document.getElementById('btn-refresh').addEventListener('click', () => {
          fetchAllData(true);
        });

        // Settings modal
        document.getElementById('btn-settings').addEventListener('click', () => {
          openSettingsModal();
        });

        document.getElementById('btn-close-settings').addEventListener('click', () => {
          closeSettingsModal();
        });

        document.getElementById('btn-cancel-settings').addEventListener('click', () => {
          closeSettingsModal();
        });

        document.getElementById('btn-save-settings').addEventListener('click', () => {
          saveSettingsModal();
        });

        document.getElementById('settings-backdrop').addEventListener('click', () => {
          closeSettingsModal();
        });

        // Settings modal tabs
        document.querySelectorAll('.settings-tab').forEach((tab) => {
          tab.addEventListener('click', () => {
            switchSettingsTab(tab.dataset.settingsTab);
          });
        });

        document.querySelectorAll('.tab').forEach((tab) => {
          tab.addEventListener('click', () => {
            switchTab(tab.dataset.tab);
          });
        });

        // Table sorting
        document.querySelectorAll('th[data-sort]').forEach((th) => {
          th.addEventListener('click', () => {
            const table = th.closest('table');
            const sortKey = th.dataset.sort;
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Simple toggle sort (ascending/descending)
            const isAsc = th.classList.contains('sort-asc');
            rows.sort((a, b) => {
              const aVal = a.querySelector(`td:nth-child(${th.cellIndex + 1})`).textContent;
              const bVal = b.querySelector(`td:nth-child(${th.cellIndex + 1})`).textContent;

              // Try numeric comparison first
              const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
              const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));

              if (!isNaN(aNum) && !isNaN(bNum)) {
                return isAsc ? bNum - aNum : aNum - bNum;
              }

              return isAsc ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
            });

            tbody.innerHTML = '';
            rows.forEach((row) => tbody.appendChild(row));

            // Toggle sort indicator
            table.querySelectorAll('th').forEach((h) => h.classList.remove('sort-asc', 'sort-desc'));
            th.classList.add(isAsc ? 'sort-desc' : 'sort-asc');
          });
        });
      };

      // Start the app
      document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>

