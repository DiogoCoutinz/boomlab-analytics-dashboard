<!DOCTYPE html>
<html lang="pt-PT">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard de Analytics ‚Äî BoomLab</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

    <!-- Day.js + plugins -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>

    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
      /* Custom dark theme */
      body {
        background: #0f0f0f;
        color: #e5e5e5;
      }

      .card {
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        transition: all 0.2s ease;
      }

      .card:hover {
        border-color: #3a3a3a;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .tab {
        cursor: pointer;
        padding: 0.75rem 1.5rem;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
        color: #9ca3af;
      }

      .tab:hover {
        color: #e5e5e5;
      }

      .tab.active {
        color: #3b82f6;
        border-bottom-color: #3b82f6;
      }

      .skeleton {
        background: linear-gradient(90deg, #1a1a1a 25%, #2a2a2a 50%, #1a1a1a 75%);
        background-size: 200% 100%;
        animation: loading 1.5s ease-in-out infinite;
      }

      @keyframes loading {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th {
        position: sticky;
        top: 0;
        background: #1a1a1a;
        padding: 0.75rem;
        text-align: left;
        font-weight: 600;
        border-bottom: 2px solid #3a3a3a;
        cursor: pointer;
        user-select: none;
      }

      th:hover {
        background: #2a2a2a;
      }

      td {
        padding: 0.75rem;
        border-bottom: 1px solid #2a2a2a;
      }

      tr:hover {
        background: #1f1f1f;
      }

      select,
      input[type="date"] {
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        color: #e5e5e5;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
      }

      select:focus,
      input[type="date"]:focus {
        outline: none;
        border-color: #3b82f6;
      }

      .delta-positive {
        color: #10b981;
      }

      .delta-negative {
        color: #ef4444;
      }

      /* Chart container */
      .chart-container {
        position: relative;
        height: 300px;
      }

      .btn {
        background: #3b82f6;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn:hover {
        background: #2563eb;
      }

      .btn:disabled {
        background: #374151;
        cursor: not-allowed;
      }

      /* Tooltip icon */
      .tooltip-icon {
        display: inline-block;
        font-size: 0.75rem;
        opacity: 0.5;
        cursor: help;
        transition: opacity 0.2s ease;
      }

      .tooltip-icon:hover {
        opacity: 1;
      }

      /* Cursor help for tooltips */
      .cursor-help {
        cursor: help;
        text-decoration: underline;
        text-decoration-style: dotted;
        text-decoration-color: #3a3a3a;
        text-underline-offset: 2px;
      }

      .cursor-help:hover {
        text-decoration-color: #9ca3af;
      }
    </style>
  </head>

  <body class="font-sans">
    <!-- Header -->
    <header class="border-b border-gray-800 bg-black/50 backdrop-blur-sm sticky top-0 z-50">
      <div class="container mx-auto px-6 py-4">
        <h1 class="text-2xl font-bold">üìà Dashboard de Analytics ‚Äî BoomLab</h1>
      </div>
    </header>

    <!-- Provisional Data Warning (hidden by default) -->
    <div id="provisional-warning" class="hidden bg-amber-900/30 border-b border-amber-700/50">
      <div class="container mx-auto px-6 py-3">
        <div class="flex items-center gap-2 text-amber-400 text-sm">
          <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
          </svg>
          <span><strong>Dados provis√≥rios:</strong> Os dados de hoje s√£o atualizados de hora em hora. Dados consolidados ficam dispon√≠veis amanh√£ √†s 14h.</span>
        </div>
      </div>
    </div>

    <!-- Filters -->
    <section class="border-b border-gray-800 bg-black/30">
      <div class="container mx-auto px-6 py-4">
        <div class="flex flex-wrap gap-4 items-end">
          <!-- Period -->
          <div class="flex-1 min-w-[200px]">
            <label class="block text-sm text-gray-400 mb-2">Per√≠odo</label>
            <select id="filter-period" class="w-full">
              <option value="today">Hoje</option>
              <option value="yesterday">Ontem</option>
              <option value="7d" selected>√öltimos 7 dias</option>
              <option value="30d">√öltimos 30 dias</option>
              <option value="90d">√öltimos 90 dias</option>
              <option value="ytd">Ano (YTD)</option>
              <option value="custom">Personalizado</option>
            </select>
          </div>

          <!-- Custom date range (hidden by default) -->
          <div id="custom-range" class="hidden flex-1 min-w-[200px] flex gap-2">
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-2">De</label>
              <input type="date" id="filter-date-from" class="w-full" />
            </div>
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-2">At√©</label>
              <input type="date" id="filter-date-to" class="w-full" />
            </div>
          </div>

          <!-- Domain (Hostname) -->
          <div class="flex-1 min-w-[200px]">
            <label class="block text-sm text-gray-400 mb-2">Dom√≠nio</label>
            <select id="filter-hostname" class="w-full">
              <option value="">Todos os dom√≠nios</option>
            </select>
          </div>
        </div>

        <!-- Compare Toggle -->
        <div class="mt-4 flex items-center gap-2">
          <input type="checkbox" id="toggle-compare" class="w-4 h-4 cursor-pointer" />
          <label for="toggle-compare" class="text-sm text-gray-400 cursor-pointer select-none">
            Comparar com per√≠odo anterior
          </label>
        </div>
      </div>
    </section>

    <!-- KPI Cards -->
    <section class="container mx-auto px-6 py-8">
      <div id="kpi-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-4">
        <!-- Skeletons (will be replaced) -->
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
        <div class="card rounded-lg p-4">
          <div class="skeleton h-4 w-20 mb-2 rounded"></div>
          <div class="skeleton h-8 w-16 mb-2 rounded"></div>
          <div class="skeleton h-3 w-12 rounded"></div>
        </div>
      </div>
    </section>

    <!-- Tabs -->
    <section class="container mx-auto px-6">
      <div class="flex border-b border-gray-800">
        <div class="tab active" data-tab="overview">Vis√£o Geral</div>
        <div class="tab" data-tab="pages">P√°ginas</div>
        <div class="tab" data-tab="acquisition">Aquisi√ß√£o</div>
      </div>
    </section>

    <!-- Tab Content -->
    <section class="container mx-auto px-6 py-8">
      <!-- Overview Tab -->
      <div id="tab-overview" class="tab-content">
        <div class="grid grid-cols-1 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Evolu√ß√£o Temporal</h3>
            <div class="chart-container" style="height: 300px;">
              <canvas id="chart-overview-timeline"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Pages Tab -->
      <div id="tab-pages" class="tab-content hidden">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Top P√°ginas</h3>
            <div class="overflow-x-auto">
              <table id="table-pages">
                <thead>
                  <tr>
                    <th data-sort="page_path">P√°gina</th>
                    <th data-sort="sessions">Sessions</th>
                    <th data-sort="unique_users">Users</th>
                    <th data-sort="avg_session_duration">Dura√ß√£o M√©dia</th>
                    <th data-sort="engagement_rate">Eng. Rate</th>
                    <th data-sort="bounce_rate">Bounce Rate</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">P√°ginas por Sessions</h3>
            <div class="chart-container">
              <canvas id="chart-pages-bar"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Acquisition Tab -->
      <div id="tab-acquisition" class="tab-content hidden">
        <div id="acquisition-content" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Sessions por Canal</h3>
            <div class="chart-container">
              <canvas id="chart-acquisition-donut"></canvas>
            </div>
          </div>
          <div class="card rounded-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Fontes de Tr√°fego</h3>
            <div class="overflow-x-auto">
              <table id="table-acquisition">
                <thead>
                  <tr>
                    <th data-sort="channel">Canal</th>
                    <th data-sort="source_medium">Fonte / Meio</th>
                    <th data-sort="sessions">Sessions</th>
                    <th data-sort="unique_users">Users</th>
                    <th data-sort="engagement_rate">Eng. Rate</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Empty state -->
        <div id="acquisition-empty" class="hidden card rounded-lg p-12 text-center">
          <svg class="mx-auto h-16 w-16 text-gray-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
          <p class="text-gray-400 text-lg">Sem dados de aquisi√ß√£o ainda</p>
          <p class="text-gray-500 text-sm mt-2">Os dados de canais e fontes aparecer√£o aqui quando dispon√≠veis</p>
        </div>
      </div>

    </section>

    <!-- Footer -->
    <footer class="border-t border-gray-800 bg-black/30 mt-12">
      <div class="container mx-auto px-6 py-4 flex justify-between items-center">
        <div class="text-sm text-gray-400">
          √öltima atualiza√ß√£o: <span id="last-update" class="font-mono">--:--</span>
        </div>
        <button id="btn-refresh" class="btn">
          üîÑ Atualizar
        </button>
      </div>
    </footer>

    <script>
      // ========================================
      // CONFIG
      // ========================================

      const CONFIG = {
        supabase: {
          url: 'https://uvvxvqrymdywxoqgnnvd.supabase.co',
          anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV2dnh2cXJ5bWR5d3hvcWdubnZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwODM3NDAsImV4cCI6MjA3NDY1OTc0MH0.3vNlo61Yl4c3XG7-8yDCKVBO4-f0iNMJeHXSSgzAI5w',
        },
        locale: 'pt-PT',
        timezone: 'Europe/Lisbon',
        colors: {
          primary: '#3b82f6',
          success: '#10b981',
          danger: '#ef4444',
          warning: '#f59e0b',
        },
      };

      // Metric descriptions for tooltips
      const METRIC_DESCRIPTIONS = {
        totalUsers: 'Utilizadores √∫nicos ativos (1-day active users). Sem duplica√ß√µes entre p√°ginas/dispositivos.',
        newUsers: 'Novos utilizadores que visitaram o site pela primeira vez.',
        sessions: 'N√∫mero total de sess√µes iniciadas neste per√≠odo.',
        engagementRate: 'Percentagem de sess√µes com intera√ß√£o (‚â•10s, convers√£o ou ‚â•2 pageviews).',
        avgDuration: 'Tempo m√©dio de dura√ß√£o das sess√µes.',
        bounceRate: 'Percentagem de sess√µes sem intera√ß√£o (1 - engagement rate).',
      };

      // Initialize Supabase client
      const supabase = window.supabase.createClient(CONFIG.supabase.url, CONFIG.supabase.anonKey);

      // Initialize Day.js plugins
      dayjs.extend(window.dayjs_plugin_utc);
      dayjs.extend(window.dayjs_plugin_timezone);
      dayjs.extend(window.dayjs_plugin_customParseFormat);
      dayjs.tz.setDefault(CONFIG.timezone);

      // ========================================
      // STATE
      // ========================================

      const state = {
        filters: {
          period: '7d',
          dateFrom: null,
          dateTo: null,
          hostname: '',
        },
        datasets: {
          kpisCurrent: [],
          kpisPrevious: [],
          pages: [],
          acquisition: [],
        },
        cache: new Map(),
        loading: false,
        activeTab: 'overview',
        compareMode: false,
        lastRefresh: null,
        lastRefreshInWindow: false,
      };

      // Chart instances (to destroy before re-render)
      const charts = {};

      // ========================================
      // FORMATTERS
      // ========================================

      const fmtNumber = (n) => {
        if (n == null) return '‚Äî';
        return new Intl.NumberFormat(CONFIG.locale).format(Math.round(n));
      };

      const fmtPercent = (n) => {
        if (n == null) return '‚Äî';
        return `${(n * 100).toLocaleString(CONFIG.locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%`;
      };

      const fmtDuration = (seconds) => {
        if (seconds == null || seconds === 0) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const fmtDate = (date) => {
        return dayjs(date).format('DD/MM/YYYY');
      };

      const fmtDelta = (current, previous) => {
        if (previous == null || previous === 0) return null;
        return ((current - previous) / previous) * 100;
      };

      // Clean and format source/medium strings
      const cleanSourceMedium = (sourceMedium) => {
        if (!sourceMedium || sourceMedium === 'Unknown') return '(n√£o definido)';
        
        // URL decode: replace + with space and decode %XX
        let cleaned = sourceMedium.replace(/\+/g, ' ').replace(/%([0-9A-F]{2})/gi, (_, hex) => 
          String.fromCharCode(parseInt(hex, 16))
        );
        
        // Check for long numeric IDs (likely campaign IDs)
        if (/^\d{10,}/.test(cleaned)) {
          const match = cleaned.match(/^(\d+)\s*\/\s*(.+)$/);
          if (match) {
            return `Campaign ${match[1].slice(0, 8)}... / ${match[2]}`;
          }
          return `Campaign ${cleaned.slice(0, 12)}...`;
        }
        
        // Map known patterns to friendly names
        const patterns = [
          { regex: /^fb\s*\/\s*paid$/i, label: 'Facebook Ads' },
          { regex: /^ig\s*\/\s*paid$/i, label: 'Instagram Ads' },
          { regex: /^google\s*\/\s*cpc$/i, label: 'Google Ads' },
          { regex: /^google\s*\/\s*organic$/i, label: 'Google (org√¢nico)' },
          { regex: /^bing\s*\/\s*organic$/i, label: 'Bing (org√¢nico)' },
          { regex: /^an\s*\/\s*paid$/i, label: 'An√∫ncios (outras redes)' },
          { regex: /^fb\s*\/\s*(.+)/i, label: (m) => `Facebook / ${m[1]}` },
          { regex: /^ig\s*\/\s*(.+)/i, label: (m) => `Instagram / ${m[1]}` },
          { regex: /^adsmanager\.facebook\.com\s*\/\s*(.+)/i, label: 'Facebook Ads Manager' },
          { regex: /^app\.gohighlevel\.com\s*\/\s*(.+)/i, label: 'GoHighLevel' },
          { regex: /^business\.facebook\.com\s*\/\s*(.+)/i, label: 'Facebook Business' },
          { regex: /^\(direct\)\s*\/\s*\(none\)$/i, label: 'Direto' },
          { regex: /^\(not\s+set\)$/i, label: '(n√£o definido)' },
        ];
        
        for (const pattern of patterns) {
          const match = cleaned.match(pattern.regex);
          if (match) {
            return typeof pattern.label === 'function' ? pattern.label(match) : pattern.label;
          }
        }
        
        // Truncate very long strings
        if (cleaned.length > 60) {
          return cleaned.slice(0, 57) + '...';
        }
        
        return cleaned;
      };

      const cleanChannel = (channel) => {
        if (!channel || channel === 'Unknown') return 'Unassigned';
        
        const mapping = {
          'Organic Social': 'Redes Sociais (Org√¢nico)',
          'Paid Social': 'Redes Sociais (Pago)',
          'Organic Search': 'Pesquisa Org√¢nica',
          'Paid Search': 'Pesquisa Paga',
          'Direct': 'Direto',
          'Referral': 'Refer√™ncia',
          'Email': 'Email',
          'Affiliates': 'Afiliados',
          'Display': 'Display',
          'Paid Other': 'Outro (Pago)',
          'Unassigned': 'N√£o Categorizado'
        };
        
        return mapping[channel] || channel;
      };

      // ========================================
      // UTILS
      // ========================================

      const getDateRange = (period) => {
        const now = dayjs().tz(CONFIG.timezone);
        let from, to;

        switch (period) {
          case 'today':
            from = to = now.format('YYYY-MM-DD');
            break;
          case 'yesterday':
            from = to = now.subtract(1, 'day').format('YYYY-MM-DD');
            break;
          case '7d':
            from = now.subtract(6, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case '30d':
            from = now.subtract(29, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case '90d':
            from = now.subtract(89, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case 'ytd':
            from = now.startOf('year').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
            break;
          case 'custom':
            from = state.filters.dateFrom || now.subtract(6, 'day').format('YYYY-MM-DD');
            to = state.filters.dateTo || now.format('YYYY-MM-DD');
            break;
          default:
            from = now.subtract(6, 'day').format('YYYY-MM-DD');
            to = now.format('YYYY-MM-DD');
        }

        return { from, to };
      };

      const getPreviousPeriod = (from, to) => {
        const fromDate = dayjs(from);
        const toDate = dayjs(to);
        const duration = toDate.diff(fromDate, 'day') + 1;

        const prevTo = fromDate.subtract(1, 'day').format('YYYY-MM-DD');
        const prevFrom = fromDate.subtract(duration, 'day').format('YYYY-MM-DD');

        return { from: prevFrom, to: prevTo };
      };

      const sum = (arr, key) => {
        return arr.reduce((acc, item) => acc + (item[key] || 0), 0);
      };

      const weightedAvg = (arr, valueKey, weightKey) => {
        const totalWeight = sum(arr, weightKey);
        if (totalWeight === 0) return 0;
        const weightedSum = arr.reduce((acc, item) => acc + (item[valueKey] || 0) * (item[weightKey] || 0), 0);
        return weightedSum / totalWeight;
      };

      // ========================================
      // FETCH
      // ========================================

      const fetchDailyKPIs = async (from, to, filters = {}) => {
        // If hostname filter is applied, query analytics_users_summary with hostname filter
        if (filters.hostname) {
          let query = supabase
            .from('analytics_users_summary')
            .select('*')
            .gte('date', from)
            .lte('date', to)
            .eq('hostname', filters.hostname)
            .order('date', { ascending: true });

          const { data, error } = await query;
          if (error) throw error;

          console.log('üìä Raw data from Supabase (with hostname filter):', data);

          return (data || []).map((row) => {
            // Normalize engagement_rate: if > 1, it's already percentage; if < 1, it's decimal
            let engRate = row.engagement_rate || 0;
            if (engRate > 0 && engRate <= 1) {
              engRate = engRate; // Keep as decimal (0.83)
            } else if (engRate > 1) {
              engRate = engRate / 100; // Convert percentage to decimal (83 -> 0.83)
            }

          return {
            date: row.date,
            total_users: row.total_users,
            sessions: row.sessions,
            new_users: row.new_users,
            engagement_rate: engRate,
            avg_session_duration: row.avg_session_duration || 0,
            bounce_rate: row.bounce_rate || 0,
          };
          });
        }

        // No filters: use analytics_completo table with global hostname (already aggregated, no duplicates)
        let query = supabase
          .from('analytics_completo')
          .select('*')
          .gte('date', from)
          .lte('date', to)
          .eq('hostname', 'global')
          .order('date', { ascending: true });

        const { data, error } = await query;
        if (error) throw error;

        console.log('üìä Raw data from Supabase (global aggregated):', data);

        return (data || []).map((row) => {
          // Normalize engagement_rate: if > 1, it's already percentage; if < 1, it's decimal
          let engRate = row.engagement_rate || 0;
          if (engRate > 0 && engRate <= 1) {
            engRate = engRate; // Keep as decimal (0.33)
          } else if (engRate > 1) {
            engRate = engRate / 100; // Convert percentage to decimal (33 -> 0.33)
          }

          return {
            date: row.date,
            total_users: row.total_users,
            sessions: row.sessions,
            new_users: row.new_users,
            engagement_rate: engRate,
            avg_session_duration: row.avg_session_duration || 0,
            bounce_rate: row.bounce_rate || 0,
          };
        }).sort((a, b) => (a.date > b.date ? 1 : -1));
      };

      const fetchPages = async (from, to, filters = {}) => {
        // Fetch from analytics_core and aggregate by page
        let query = supabase
          .from('analytics_core')
          .select('page_path, hostname, unique_users, sessions, new_users, avg_session_duration, engagement_rate, bounce_rate')
          .gte('date', from)
          .lte('date', to);

        // Apply hostname filter if set
        if (filters.hostname) {
          query = query.eq('hostname', filters.hostname);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate by page_path
        const aggregated = {};
        (data || []).forEach((row) => {
          const key = row.page_path;
          if (!aggregated[key]) {
            aggregated[key] = {
              page_path: key,
              unique_users: 0,
              sessions: 0,
              new_users: 0,
              _eng_weighted: 0,
              _dur_weighted: 0,
              _bounce_weighted: 0,
            };
          }
          aggregated[key].unique_users += row.unique_users || 0;
          aggregated[key].sessions += row.sessions || 0;
          aggregated[key].new_users += row.new_users || 0;
          aggregated[key]._eng_weighted += (row.engagement_rate || 0) * (row.sessions || 0);
          aggregated[key]._dur_weighted += (row.avg_session_duration || 0) * (row.sessions || 0);
          aggregated[key]._bounce_weighted += (row.bounce_rate || 0) * (row.sessions || 0);
        });

        return Object.values(aggregated).map((page) => {
          const engRate = page.sessions > 0 ? page._eng_weighted / page.sessions : 0;
          return {
            ...page,
            engagement_rate: engRate,
            avg_session_duration: page.sessions > 0 ? page._dur_weighted / page.sessions : 0,
            bounce_rate: 1 - engRate, // Calculate from engagement_rate instead of DB field
          };
        }).sort((a, b) => b.sessions - a.sessions);
      };

      const fetchAcquisition = async (from, to, filters = {}) => {
        // Fetch acquisition data and aggregate
        let query = supabase
          .from('analytics_acquisition')
          .select('hostname, session_source_medium, session_channel_group, unique_users, sessions, engagement_rate')
          .gte('date', from)
          .lte('date', to);

        // Apply hostname filter if set
        if (filters.hostname) {
          query = query.eq('hostname', filters.hostname);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate by channel/source
        const aggregated = {};
        (data || []).forEach((row) => {
          const key = `${row.session_channel_group || 'Unknown'}-${row.session_source_medium || 'Unknown'}`;
          if (!aggregated[key]) {
            aggregated[key] = {
              channel: row.session_channel_group || 'Unknown',
              source_medium: row.session_source_medium || 'Unknown',
              unique_users: 0,
              sessions: 0,
              _eng_weighted: 0,
            };
          }
          aggregated[key].unique_users += row.unique_users || 0;
          aggregated[key].sessions += row.sessions || 0;
          aggregated[key]._eng_weighted += (row.engagement_rate || 0) * (row.sessions || 0);
        });

        return Object.values(aggregated).map((item) => ({
          ...item,
          engagement_rate: item.sessions > 0 ? item._eng_weighted / item.sessions : 0,
        })).sort((a, b) => b.sessions - a.sessions);
      };

      const fetchFilterOptions = async () => {
        // Fetch unique hostnames for dropdown
        const { data: hostnames } = await supabase
          .from('analytics_core')
          .select('hostname')
          .not('hostname', 'is', null)
          .order('hostname');

        const uniqueHostnames = [...new Set(hostnames?.map((h) => h.hostname) || [])];

        return { hostnames: uniqueHostnames };
      };

      // ========================================
      // COMPUTE
      // ========================================

      const computeKPIs = (kpisData) => {
        const totalUsers = sum(kpisData, 'total_users');
        const newUsers = sum(kpisData, 'new_users');
        const sessions = sum(kpisData, 'sessions');
        const engagementRate = weightedAvg(kpisData, 'engagement_rate', 'sessions');
        const avgDuration = weightedAvg(kpisData, 'avg_session_duration', 'sessions');
        
        // Calculate bounce rate as 1 - engagement_rate (field bounce_rate is always 0 in DB)
        const bounceRate = 1 - engagementRate;

        return {
          totalUsers,
          newUsers,
          sessions,
          engagementRate,
          avgDuration,
          bounceRate,
        };
      };


      // ========================================
      // RENDER
      // ========================================

      const renderKPICards = (current, previous) => {
        const kpis = [
          {
            label: 'Total Users',
            value: current.totalUsers,
            prev: previous.totalUsers,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.totalUsers,
          },
          {
            label: 'New Users',
            value: current.newUsers,
            prev: previous.newUsers,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.newUsers,
          },
          {
            label: 'Sessions',
            value: current.sessions,
            prev: previous.sessions,
            format: fmtNumber,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.sessions,
          },
          {
            label: 'Engagement Rate',
            value: current.engagementRate,
            prev: previous.engagementRate,
            format: fmtPercent,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.engagementRate,
          },
          {
            label: 'Avg. Duration',
            value: current.avgDuration,
            prev: previous.avgDuration,
            format: fmtDuration,
            invertDelta: false,
            tooltip: METRIC_DESCRIPTIONS.avgDuration,
          },
          {
            label: 'Bounce Rate',
            value: current.bounceRate,
            prev: previous.bounceRate,
            format: fmtPercent,
            invertDelta: true, // Lower is better
            tooltip: METRIC_DESCRIPTIONS.bounceRate,
          },
        ];

        const html = kpis
          .map((kpi) => {
            const delta = fmtDelta(kpi.value, kpi.prev);
            const deltaClass =
              delta == null
                ? ''
                : delta > 0
                ? kpi.invertDelta
                  ? 'delta-negative'
                  : 'delta-positive'
                : kpi.invertDelta
                ? 'delta-positive'
                : 'delta-negative';
            const deltaIcon = delta == null ? '' : delta > 0 ? '‚Üë' : '‚Üì';
            const deltaText =
              delta == null
                ? ''
                : `${deltaIcon} ${Math.abs(delta).toLocaleString(CONFIG.locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%`;

            return `
            <div class="card rounded-lg p-4">
              <div class="flex items-center gap-1 text-sm text-gray-400 mb-1">
                <span>${kpi.label}</span>
                <span class="tooltip-icon" title="${kpi.tooltip}">‚ÑπÔ∏è</span>
              </div>
              <div class="text-2xl font-bold mb-1">${kpi.format(kpi.value)}</div>
              <div class="text-xs ${deltaClass}">${deltaText || '‚Äî'}</div>
            </div>
          `;
          })
          .join('');

        document.getElementById('kpi-cards').innerHTML = html;
      };

      const renderOverviewChart = (kpisData) => {
        const ctx = document.getElementById('chart-overview-timeline');
        if (!ctx) return;

        // Destroy previous chart
        if (charts.overview) charts.overview.destroy();

        // Prepare data by date
        const sorted = kpisData.sort((a, b) => (a.date > b.date ? 1 : -1));

        const labels = sorted.map((d) => fmtDate(d.date));
        const sessions = sorted.map((d) => d.sessions);
        const users = sorted.map((d) => d.total_users); // Fix: use snake_case
        const engagement = sorted.map((d) => (d.engagement_rate || 0) * 100); // Fix: use snake_case

        // Debug log
        console.log('üìä Chart Data:', { sessions, users, engagement, kpisData });

        const datasets = [
          {
            label: 'Sessions',
            data: sessions,
            borderColor: CONFIG.colors.primary,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
          {
            label: 'Users',
            data: users,
            borderColor: CONFIG.colors.success,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
          {
            label: 'Engagement Rate (%)',
            data: engagement,
            borderColor: CONFIG.colors.warning,
            backgroundColor: 'transparent',
            borderWidth: 3,
            tension: 0.4,
            yAxisID: 'y1',
            pointRadius: 4,
            pointHoverRadius: 6,
          },
        ];

        // Add previous period data if compare mode is active
        if (state.compareMode && state.datasets.kpisPrevious.length > 0) {
          const prevDataByDate = {};
          state.datasets.kpisPrevious.forEach((row) => {
            prevDataByDate[row.date] = {
              date: row.date,
              sessions: row.sessions,
              total_users: row.total_users,
              engagement_rate: row.engagement_rate,
            };
          });

          const prevSorted = Object.values(prevDataByDate).sort((a, b) => (a.date > b.date ? 1 : -1));
          const prevSessions = prevSorted.map((d) => d.sessions);
          const prevUsers = prevSorted.map((d) => d.total_users); // Fix: use snake_case
          const prevEngagement = prevSorted.map((d) => (d.engagement_rate || 0) * 100); // Fix: use snake_case

          datasets.push(
            {
              label: 'Sessions (anterior)',
              data: prevSessions,
              borderColor: CONFIG.colors.primary,
              backgroundColor: 'transparent',
              tension: 0.3,
              yAxisID: 'y',
              borderDash: [5, 5],
              borderWidth: 1.5,
            },
            {
              label: 'Users (anterior)',
              data: prevUsers,
              borderColor: CONFIG.colors.success,
              backgroundColor: 'transparent',
              tension: 0.3,
              yAxisID: 'y',
              borderDash: [5, 5],
              borderWidth: 1.5,
            },
            {
              label: 'Engagement Rate (%) (anterior)',
              data: prevEngagement,
              borderColor: CONFIG.colors.warning,
              backgroundColor: 'transparent',
              tension: 0.3,
              yAxisID: 'y1',
              borderDash: [5, 5],
              borderWidth: 1.5,
            }
          );
        }

        charts.overview = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            layout: {
              padding: {
                top: 10,
                right: 10,
                bottom: 10,
                left: 10,
              },
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                align: 'end',
                labels: { 
                  color: '#e5e5e5',
                  padding: 15,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  filter: (item) => {
                    // Remove duplicates: show only current period labels
                    return !item.text.includes('(anterior)');
                  }
                },
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                padding: 12,
                displayColors: true,
                callbacks: {
                  label: (context) => {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      if (context.dataset.yAxisID === 'y1') {
                        label += context.parsed.y.toFixed(1) + '%';
                      } else {
                        label += context.parsed.y.toLocaleString('pt-PT');
                      }
                    }
                    return label;
                  }
                },
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                type: 'linear',
                position: 'left',
                beginAtZero: true,
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
                title: {
                  display: true,
                  text: 'Sessions / Users',
                  color: '#9ca3af',
                },
              },
              y1: {
                type: 'linear',
                position: 'right',
                min: 0,
                max: 100,
                ticks: { 
                  color: '#9ca3af',
                  callback: (value) => `${value}%`,
                },
                grid: { display: false },
                title: {
                  display: true,
                  text: 'Engagement Rate',
                  color: '#f59e0b',
                },
              },
            },
          },
        });
      };

      const renderPagesTable = (pages) => {
        const tbody = document.querySelector('#table-pages tbody');
        if (!tbody) return;

        const html = pages
          .slice(0, 20) // Top 20
          .map((page) => {
            return `
            <tr>
              <td class="font-mono text-sm">${page.page_path}</td>
              <td>${fmtNumber(page.sessions)}</td>
              <td>${fmtNumber(page.unique_users)}</td>
              <td>${fmtDuration(page.avg_session_duration)}</td>
              <td>${fmtPercent(page.engagement_rate)}</td>
              <td>${fmtPercent(page.bounce_rate)}</td>
            </tr>
          `;
          })
          .join('');

        tbody.innerHTML = html || '<tr><td colspan="6" class="text-center text-gray-500">Sem dados</td></tr>';
      };

      const renderPagesBarChart = (pages) => {
        const ctx = document.getElementById('chart-pages-bar');
        if (!ctx) return;

        if (charts.pagesBar) charts.pagesBar.destroy();

        const top10 = pages.slice(0, 10);
        const labels = top10.map((p) => p.page_path);
        const data = top10.map((p) => p.sessions);

        charts.pagesBar = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Sessions',
                data,
                backgroundColor: CONFIG.colors.primary,
              },
            ],
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
              },
            },
            scales: {
              x: {
                ticks: { color: '#9ca3af' },
                grid: { color: '#2a2a2a' },
              },
              y: {
                ticks: { color: '#9ca3af', font: { size: 10 } },
                grid: { display: false },
              },
            },
          },
        });
      };


      const renderAcquisitionTable = (acquisition) => {
        const tbody = document.querySelector('#table-acquisition tbody');
        if (!tbody) return;

        const html = acquisition
          .map((row) => {
            const channelClean = cleanChannel(row.channel);
            const sourceClean = cleanSourceMedium(row.source_medium);
            
            return `
            <tr>
              <td>
                <span title="${row.channel}">${channelClean}</span>
              </td>
              <td class="text-sm">
                <span title="${row.source_medium}" class="cursor-help">${sourceClean}</span>
              </td>
              <td>${fmtNumber(row.sessions)}</td>
              <td>${fmtNumber(row.unique_users)}</td>
              <td>${fmtPercent(row.engagement_rate)}</td>
            </tr>
          `;
          })
          .join('');

        tbody.innerHTML = html || '<tr><td colspan="5" class="text-center text-gray-500">Sem dados</td></tr>';
      };

      const renderAcquisitionDonutChart = (acquisition) => {
        const ctx = document.getElementById('chart-acquisition-donut');
        if (!ctx) return;

        if (charts.acquisitionDonut) charts.acquisitionDonut.destroy();

        // Group by channel (aggregate multiple sources)
        const channelGroups = {};
        acquisition.forEach((row) => {
          const channelKey = row.channel || 'Unknown';
          if (!channelGroups[channelKey]) {
            channelGroups[channelKey] = {
              channel: channelKey,
              sessions: 0,
              sources: []
            };
          }
          channelGroups[channelKey].sessions += row.sessions || 0;
          channelGroups[channelKey].sources.push(row.source_medium);
        });

        const grouped = Object.values(channelGroups).sort((a, b) => b.sessions - a.sessions);
        const labels = grouped.map((g) => cleanChannel(g.channel));
        const data = grouped.map((g) => g.sessions);

        charts.acquisitionDonut = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [
              {
                data,
                backgroundColor: [
                  CONFIG.colors.primary,
                  CONFIG.colors.success,
                  CONFIG.colors.warning,
                  CONFIG.colors.danger,
                  '#8b5cf6',
                  '#ec4899',
                  '#f97316',
                  '#06b6d4',
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                labels: { color: '#e5e5e5', padding: 12 },
                position: 'bottom',
              },
              tooltip: {
                backgroundColor: '#1a1a1a',
                titleColor: '#e5e5e5',
                bodyColor: '#9ca3af',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                callbacks: {
                  label: (context) => {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${context.label}: ${value.toLocaleString('pt-PT')} (${percentage}%)`;
                  }
                }
              },
            },
          },
        });
      };

      const showEmptyState = (show) => {
        const empty = document.getElementById('acquisition-empty');
        const content = document.getElementById('acquisition-content');
        if (show) {
          empty.classList.remove('hidden');
          content.classList.add('hidden');
        } else {
          empty.classList.add('hidden');
          content.classList.remove('hidden');
        }
      };


      // ========================================
      // EVENTS
      // ========================================

      const updateFilters = () => {
        const period = document.getElementById('filter-period').value;
        const hostname = document.getElementById('filter-hostname').value;

        state.filters.period = period;
        state.filters.hostname = hostname;

        // Show/hide custom date inputs
        const customRange = document.getElementById('custom-range');
        if (period === 'custom') {
          customRange.classList.remove('hidden');
        } else {
          customRange.classList.add('hidden');
        }

        saveFiltersToLocalStorage();
        updateQueryParams();
      };

      const saveFiltersToLocalStorage = () => {
        localStorage.setItem('boomlab-filters', JSON.stringify(state.filters));
      };

      const loadFiltersFromLocalStorage = () => {
        const saved = localStorage.getItem('boomlab-filters');
        if (saved) {
          const parsed = JSON.parse(saved);
          state.filters = { ...state.filters, ...parsed };
        }
      };

      const updateQueryParams = () => {
        const params = new URLSearchParams();
        if (state.filters.period) params.set('period', state.filters.period);
        if (state.filters.hostname) params.set('hostname', state.filters.hostname);
        if (state.activeTab) params.set('tab', state.activeTab);

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newUrl);
      };

      const loadFiltersFromQueryParams = () => {
        const params = new URLSearchParams(window.location.search);
        if (params.has('period')) state.filters.period = params.get('period');
        if (params.has('hostname')) state.filters.hostname = params.get('hostname');
        if (params.has('tab')) state.activeTab = params.get('tab');
      };

      const applyFiltersToUI = () => {
        document.getElementById('filter-period').value = state.filters.period || '7d';
        document.getElementById('filter-hostname').value = state.filters.hostname || '';

        // Show custom range if needed
        if (state.filters.period === 'custom') {
          document.getElementById('custom-range').classList.remove('hidden');
          if (state.filters.dateFrom) document.getElementById('filter-date-from').value = state.filters.dateFrom;
          if (state.filters.dateTo) document.getElementById('filter-date-to').value = state.filters.dateTo;
        }
      };

      const switchTab = (tabName) => {
        state.activeTab = tabName;

        // Update tab UI
        document.querySelectorAll('.tab').forEach((tab) => {
          tab.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

        // Show/hide content
        document.querySelectorAll('.tab-content').forEach((content) => {
          content.classList.add('hidden');
        });
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');

        updateQueryParams();
        renderTabContent(tabName);
      };

      const renderTabContent = (tabName) => {
        switch (tabName) {
          case 'overview':
            renderOverviewChart(state.datasets.kpisCurrent);
            break;
          case 'pages':
            renderPagesTable(state.datasets.pages);
            renderPagesBarChart(state.datasets.pages);
            break;
          case 'acquisition':
            if (state.datasets.acquisition.length === 0) {
              showEmptyState(true);
            } else {
              showEmptyState(false);
              renderAcquisitionTable(state.datasets.acquisition);
              renderAcquisitionDonutChart(state.datasets.acquisition);
            }
            break;
        }
      };

      // ========================================
      // PROVISIONAL DATA WARNING
      // ========================================

      const checkProvisionalData = () => {
        const { to } = getDateRange(state.filters.period);
        const today = dayjs().tz(CONFIG.timezone).format('YYYY-MM-DD');
        const isToday = to === today;

        const warning = document.getElementById('provisional-warning');
        if (isToday) {
          warning.classList.remove('hidden');
        } else {
          warning.classList.add('hidden');
        }
      };

      // ========================================
      // FETCH ALL DATA
      // ========================================

      const fetchAllData = async (forceRefresh = false) => {
        if (state.loading) return;

        state.loading = true;
        document.getElementById('btn-refresh').disabled = true;

        try {
          // Get date range
          const { from, to } = getDateRange(state.filters.period);
          const previous = getPreviousPeriod(from, to);

          const filters = {
            hostname: state.filters.hostname,
          };

          // Fetch current + previous period + pages + acquisition in parallel
          const [kpisCurrent, kpisPrevious, pages, acquisition] = await Promise.all([
            fetchDailyKPIs(from, to, filters),
            fetchDailyKPIs(previous.from, previous.to, filters),
            fetchPages(from, to, filters),
            fetchAcquisition(from, to, filters),
          ]);

          // Update state
          state.datasets.kpisCurrent = kpisCurrent;
          state.datasets.kpisPrevious = kpisPrevious;
          state.datasets.pages = pages;
          state.datasets.acquisition = acquisition;

          // Compute KPIs
          const currentKPIs = computeKPIs(kpisCurrent);
          const previousKPIs = computeKPIs(kpisPrevious);

          // Render
          renderKPICards(currentKPIs, previousKPIs);
          renderTabContent(state.activeTab);

          // Update last refresh time
          state.lastRefresh = dayjs().tz(CONFIG.timezone);
          document.getElementById('last-update').textContent = state.lastRefresh.format('HH:mm');

          // Check if showing provisional data
          checkProvisionalData();
        } catch (error) {
          console.error('Error fetching data:', error);
          alert('Erro ao carregar dados. Verifica a consola para detalhes.');
        } finally {
          state.loading = false;
          document.getElementById('btn-refresh').disabled = false;
        }
      };

      const populateFilterOptions = async () => {
        const { hostnames } = await fetchFilterOptions();

        const hostnameSelect = document.getElementById('filter-hostname');
        hostnames.forEach((hostname) => {
          const option = document.createElement('option');
          option.value = hostname;
          option.textContent = hostname;
          hostnameSelect.appendChild(option);
        });
      };

      // ========================================
      // AUTO-REFRESH
      // ========================================

      const setupAutoRefresh = () => {
        // Auto-refresh every 2 hours
        setInterval(() => {
          console.log('[Auto-refresh] 2h interval');
          fetchAllData(true);
        }, 2 * 60 * 60 * 1000);

        // Special trigger: odd hour + minute 55-59
        setInterval(() => {
          const now = dayjs().tz(CONFIG.timezone);
          const minute = now.minute();
          const hour = now.hour();

          // Odd hours: 1, 3, 5, ..., 23
          if (hour % 2 === 1 && minute >= 55 && minute <= 59) {
            if (!state.lastRefreshInWindow) {
              console.log('[Auto-refresh] Special trigger at', now.format('HH:mm'));
              fetchAllData(true);
              state.lastRefreshInWindow = true;
            }
          } else {
            state.lastRefreshInWindow = false;
          }
        }, 60 * 1000); // Check every minute
      };

      // ========================================
      // INIT
      // ========================================

      const init = async () => {
        // Load filters
        loadFiltersFromLocalStorage();
        loadFiltersFromQueryParams();

        // Populate filter dropdowns
        await populateFilterOptions();

        // Apply filters to UI
        applyFiltersToUI();

        // Fetch data
        await fetchAllData();

        // Setup auto-refresh
        setupAutoRefresh();

        // Switch to active tab
        switchTab(state.activeTab);

        // Event listeners
        document.getElementById('filter-period').addEventListener('change', () => {
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-hostname').addEventListener('change', () => {
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-date-from').addEventListener('change', () => {
          state.filters.dateFrom = document.getElementById('filter-date-from').value;
          updateFilters();
          fetchAllData();
        });

        document.getElementById('filter-date-to').addEventListener('change', () => {
          state.filters.dateTo = document.getElementById('filter-date-to').value;
          updateFilters();
          fetchAllData();
        });

        document.getElementById('btn-refresh').addEventListener('click', () => {
          fetchAllData(true);
        });

        document.getElementById('toggle-compare').addEventListener('change', (e) => {
          state.compareMode = e.target.checked;
          // Re-render current tab to show/hide comparison
          renderTabContent(state.activeTab);
        });

        document.querySelectorAll('.tab').forEach((tab) => {
          tab.addEventListener('click', () => {
            switchTab(tab.dataset.tab);
          });
        });

        // Table sorting
        document.querySelectorAll('th[data-sort]').forEach((th) => {
          th.addEventListener('click', () => {
            const table = th.closest('table');
            const sortKey = th.dataset.sort;
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Simple toggle sort (ascending/descending)
            const isAsc = th.classList.contains('sort-asc');
            rows.sort((a, b) => {
              const aVal = a.querySelector(`td:nth-child(${th.cellIndex + 1})`).textContent;
              const bVal = b.querySelector(`td:nth-child(${th.cellIndex + 1})`).textContent;

              // Try numeric comparison first
              const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
              const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));

              if (!isNaN(aNum) && !isNaN(bNum)) {
                return isAsc ? bNum - aNum : aNum - bNum;
              }

              return isAsc ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
            });

            tbody.innerHTML = '';
            rows.forEach((row) => tbody.appendChild(row));

            // Toggle sort indicator
            table.querySelectorAll('th').forEach((h) => h.classList.remove('sort-asc', 'sort-desc'));
            th.classList.add(isAsc ? 'sort-desc' : 'sort-asc');
          });
        });
      };

      // Start the app
      document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>

